# [allow (clippy :: let_and_return , clippy :: suspicious_else_formatting , clippy :: redundant_field_names , dead_code , non_camel_case_types , non_snake_case , non_upper_case_globals , redundant_semicolons , unreachable_patterns , unused_braces , unused_imports , unused_parens , unused_qualifications , unused_unsafe , unused_variables)] pub mod types { pub mod ferment_example_thread_safe { use crate as ferment_example_thread_safe ; pub mod entry { use crate as ferment_example_thread_safe ; # [doc = "FFI-representation of the [`ferment_example_thread_safe :: entry :: PlatformProvider :: new`]"] # [no_mangle] pub unsafe extern "C" fn ferment_example_thread_safe_entry_PlatformProvider_new (context : * mut crate :: fermented :: generics :: std_sync_Arc_ferment_example_thread_safe_entry_FFIContext) -> * mut ferment_example_thread_safe :: entry :: PlatformProvider { let obj = ferment_example_thread_safe :: entry :: PlatformProvider :: new (ferment_interfaces :: FFIConversionFrom :: ffi_from (context)) ; ferment_interfaces :: boxed (obj) } } } } # [allow (clippy :: let_and_return , clippy :: suspicious_else_formatting , clippy :: redundant_field_names , dead_code , non_camel_case_types , non_snake_case , non_upper_case_globals , redundant_semicolons , unreachable_patterns , unused_braces , unused_imports , unused_parens , unused_qualifications , unused_unsafe , unused_variables)] pub mod generics { use crate as ferment_example_thread_safe ; # [repr (C)] # [derive (Clone)] pub struct std_sync_Arc_dyn_trait_Fn_ARGS_ferment_example_thread_safe_entry_FFIContext_u32_String_RTRN_String { pub obj : * mut crate :: fermented :: generics :: Fn_ARGS_ferment_example_thread_safe_entry_FFIContext_u32_String_RTRN_String } impl ferment_interfaces :: FFIConversionFrom < std :: sync :: Arc < dyn Fn (* const ferment_example_thread_safe :: entry :: FFIContext , u32 , & String) -> String > > for std_sync_Arc_dyn_trait_Fn_ARGS_ferment_example_thread_safe_entry_FFIContext_u32_String_RTRN_String { unsafe fn ffi_from_const (ffi : * const std_sync_Arc_dyn_trait_Fn_ARGS_ferment_example_thread_safe_entry_FFIContext_u32_String_RTRN_String) -> std :: sync :: Arc < dyn Fn (* const ferment_example_thread_safe :: entry :: FFIContext , u32 , & String) -> String > { let ffi_ref = & * ffi ; std :: sync :: Arc :: new (move | o_0 , o_1 , o_2 | unsafe { (& * ffi_ref . obj) . call (o_0 , o_1 , o_2) }) } } impl ferment_interfaces :: FFIConversionDestroy < std :: sync :: Arc < dyn Fn (* const ferment_example_thread_safe :: entry :: FFIContext , u32 , & String) -> String > > for std_sync_Arc_dyn_trait_Fn_ARGS_ferment_example_thread_safe_entry_FFIContext_u32_String_RTRN_String { unsafe fn destroy (ffi : * mut std_sync_Arc_dyn_trait_Fn_ARGS_ferment_example_thread_safe_entry_FFIContext_u32_String_RTRN_String) { ferment_interfaces :: unbox_any (ffi) ; ; } } impl Drop for std_sync_Arc_dyn_trait_Fn_ARGS_ferment_example_thread_safe_entry_FFIContext_u32_String_RTRN_String { fn drop (& mut self) { unsafe { ; ; } } } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_dyn_trait_Fn_ARGS_ferment_example_thread_safe_entry_FFIContext_u32_String_RTRN_String_ctor (obj : * mut crate :: fermented :: generics :: Fn_ARGS_ferment_example_thread_safe_entry_FFIContext_u32_String_RTRN_String) -> * mut std_sync_Arc_dyn_trait_Fn_ARGS_ferment_example_thread_safe_entry_FFIContext_u32_String_RTRN_String { ferment_interfaces :: boxed (std_sync_Arc_dyn_trait_Fn_ARGS_ferment_example_thread_safe_entry_FFIContext_u32_String_RTRN_String { obj }) } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_dyn_trait_Fn_ARGS_ferment_example_thread_safe_entry_FFIContext_u32_String_RTRN_String_destroy (ffi : * mut std_sync_Arc_dyn_trait_Fn_ARGS_ferment_example_thread_safe_entry_FFIContext_u32_String_RTRN_String) { ferment_interfaces :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_sync_Arc_ferment_example_thread_safe_entry_FFIContext { pub obj : * mut ferment_example_thread_safe :: entry :: FFIContext } impl ferment_interfaces :: FFIConversionFrom < std :: sync :: Arc < ferment_example_thread_safe :: entry :: FFIContext > > for std_sync_Arc_ferment_example_thread_safe_entry_FFIContext { unsafe fn ffi_from_const (ffi : * const std_sync_Arc_ferment_example_thread_safe_entry_FFIContext) -> std :: sync :: Arc < ferment_example_thread_safe :: entry :: FFIContext > { let ffi_ref = & * ffi ; std :: sync :: Arc :: from_raw (ffi_ref . obj) } } impl ferment_interfaces :: FFIConversionTo < std :: sync :: Arc < ferment_example_thread_safe :: entry :: FFIContext > > for std_sync_Arc_ferment_example_thread_safe_entry_FFIContext { unsafe fn ffi_to_const (obj : std :: sync :: Arc < ferment_example_thread_safe :: entry :: FFIContext >) -> * const std_sync_Arc_ferment_example_thread_safe_entry_FFIContext { ferment_interfaces :: boxed (Self { obj : std :: sync :: Arc :: into_raw (obj) . cast_mut () }) } } impl ferment_interfaces :: FFIConversionDestroy < std :: sync :: Arc < ferment_example_thread_safe :: entry :: FFIContext > > for std_sync_Arc_ferment_example_thread_safe_entry_FFIContext { unsafe fn destroy (ffi : * mut std_sync_Arc_ferment_example_thread_safe_entry_FFIContext) { ferment_interfaces :: unbox_any (ffi) ; ; } } impl Drop for std_sync_Arc_ferment_example_thread_safe_entry_FFIContext { fn drop (& mut self) { unsafe { ferment_interfaces :: unbox_any (self . obj) ; ; } } } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_ferment_example_thread_safe_entry_FFIContext_ctor (obj : * mut ferment_example_thread_safe :: entry :: FFIContext) -> * mut std_sync_Arc_ferment_example_thread_safe_entry_FFIContext { ferment_interfaces :: boxed (std_sync_Arc_ferment_example_thread_safe_entry_FFIContext { obj }) } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_ferment_example_thread_safe_entry_FFIContext_destroy (ffi : * mut std_sync_Arc_ferment_example_thread_safe_entry_FFIContext) { ferment_interfaces :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Fn_ARGS_ferment_example_thread_safe_entry_FFIContext_u32_String_RTRN_String { caller : unsafe extern "C" fn (* const ferment_example_thread_safe :: entry :: FFIContext , u32 , * mut std :: os :: raw :: c_char) -> * mut std :: os :: raw :: c_char , destructor : unsafe extern "C" fn (result : * mut std :: os :: raw :: c_char) , } impl Fn_ARGS_ferment_example_thread_safe_entry_FFIContext_u32_String_RTRN_String { pub unsafe fn call (& self , o_0 : * const ferment_example_thread_safe :: entry :: FFIContext , o_1 : u32 , o_2 : & String) -> String { let ffi_result = (self . caller) (o_0 , o_1 , ferment_interfaces :: FFIConversionTo :: ffi_to (o_2 . clone ())) ; let result = < std :: os :: raw :: c_char as ferment_interfaces :: FFIConversionFrom < String >> :: ffi_from (ffi_result) ; (self . destructor) (ffi_result) ; result } } unsafe impl Send for Fn_ARGS_ferment_example_thread_safe_entry_FFIContext_u32_String_RTRN_String { } unsafe impl Sync for Fn_ARGS_ferment_example_thread_safe_entry_FFIContext_u32_String_RTRN_String { } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_ferment_example_thread_safe_entry_FFIContext_u32_String_RTRN_String_ctor (caller : unsafe extern "C" fn (* const ferment_example_thread_safe :: entry :: FFIContext , u32 , * mut std :: os :: raw :: c_char) -> * mut std :: os :: raw :: c_char , destructor : unsafe extern "C" fn (* mut std :: os :: raw :: c_char)) -> * mut Fn_ARGS_ferment_example_thread_safe_entry_FFIContext_u32_String_RTRN_String { ferment_interfaces :: boxed (Fn_ARGS_ferment_example_thread_safe_entry_FFIContext_u32_String_RTRN_String { caller , destructor }) } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_ferment_example_thread_safe_entry_FFIContext_u32_String_RTRN_String_destroy (ffi : * mut Fn_ARGS_ferment_example_thread_safe_entry_FFIContext_u32_String_RTRN_String) { ferment_interfaces :: unbox_any (ffi) ; } }