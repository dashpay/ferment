# [allow (clippy :: let_and_return , clippy :: suspicious_else_formatting , clippy :: redundant_field_names , dead_code , non_camel_case_types , non_snake_case , non_upper_case_globals , redundant_semicolons , unreachable_patterns , unused_braces , unused_imports , unused_parens , unused_qualifications , unused_unsafe , unused_variables)] pub mod types { pub mod example_entry_point { use crate as example_entry_point ; pub mod wallet_provider { use crate as example_entry_point ; # [doc = "FFI-representation of the [`example_entry_point::wallet_provider::WalletProvider::new`]"] # [no_mangle] pub unsafe extern "C" fn example_entry_point_wallet_provider_WalletProvider_new (get_wallet_transaction : crate :: fermented :: generics :: Fn_ARGS_std_os_raw_c_void_Arr_u8_32_RTRN_Option_u8_32 , sign_transaction : crate :: fermented :: generics :: Fn_ARGS_std_os_raw_c_void_Arr_u8_32_bool_RTRN_Option_u8_32 , is_mine_input : crate :: fermented :: generics :: Fn_ARGS_std_os_raw_c_void_Arr_u8_32_RTRN_bool , available_coins : crate :: fermented :: generics :: Fn_ARGS_std_os_raw_c_void_bool_Arr_u8_32_example_entry_point_wallet_WalletEx_RTRN_Vec_u8_32 , select_coins : crate :: fermented :: generics :: Fn_ARGS_std_os_raw_c_void_bool_bool_bool_i32_RTRN_Vec_u8_32 , inputs_with_amount : crate :: fermented :: generics :: Fn_ARGS_std_os_raw_c_void_u64_RTRN_u32 , fresh_coinjoin_address : crate :: fermented :: generics :: Fn_ARGS_std_os_raw_c_void_bool_RTRN_Vec_u8 , commit_transaction : crate :: fermented :: generics :: Fn_ARGS_std_os_raw_c_void_Vec_u8_32_Arr_u8_32_bool_Arr_u8_32_RTRN_bool , is_masternode_or_disconnect_requested : crate :: fermented :: generics :: Fn_ARGS_std_os_raw_c_void_String_RTRN_bool , disconnect_masternode : crate :: fermented :: generics :: Fn_ARGS_std_os_raw_c_void_std_net_SocketAddr_RTRN_bool , is_synced : crate :: fermented :: generics :: Fn_ARGS_std_os_raw_c_void_RTRN_bool , send_message : crate :: fermented :: generics :: Fn_ARGS_std_os_raw_c_void_String_Vec_u8_Option_std_net_SocketAddr_bool_RTRN_bool , add_pending_masternode : crate :: fermented :: generics :: Fn_ARGS_std_os_raw_c_void_Arr_u8_32_Arr_u8_32_RTRN_bool , start_manager_async : crate :: fermented :: generics :: Fn_ARGS_std_os_raw_c_void_RTRN_ , get_coinjoin_keys : crate :: fermented :: generics :: Fn_ARGS_std_os_raw_c_void_bool_RTRN_Vec_Vec_u8 , context : * const std :: os :: raw :: c_void) -> * mut example_entry_point :: wallet_provider :: WalletProvider { let obj = example_entry_point :: wallet_provider :: WalletProvider :: new (move | o_0 , o_1 | unsafe { get_wallet_transaction . call (o_0 , o_1) } , move | o_0 , o_1 , o_2 | unsafe { sign_transaction . call (o_0 , o_1 , o_2) } , move | o_0 , o_1 | unsafe { is_mine_input . call (o_0 , o_1) } , move | o_0 , o_1 , o_2 , o_3 | unsafe { available_coins . call (o_0 , o_1 , o_2 , o_3) } , move | o_0 , o_1 , o_2 , o_3 , o_4 | unsafe { select_coins . call (o_0 , o_1 , o_2 , o_3 , o_4) } , move | o_0 , o_1 | unsafe { inputs_with_amount . call (o_0 , o_1) } , move | o_0 , o_1 | unsafe { fresh_coinjoin_address . call (o_0 , o_1) } , move | o_0 , o_1 , o_2 , o_3 , o_4 | unsafe { commit_transaction . call (o_0 , o_1 , o_2 , o_3 , o_4) } , move | o_0 , o_1 | unsafe { is_masternode_or_disconnect_requested . call (o_0 , o_1) } , move | o_0 , o_1 | unsafe { disconnect_masternode . call (o_0 , o_1) } , move | o_0 | unsafe { is_synced . call (o_0) } , move | o_0 , o_1 , o_2 , o_3 , o_4 | unsafe { send_message . call (o_0 , o_1 , o_2 , o_3 , o_4) } , move | o_0 , o_1 , o_2 | unsafe { add_pending_masternode . call (o_0 , o_1 , o_2) } , move | o_0 | unsafe { start_manager_async . call (o_0) } , move | o_0 , o_1 | unsafe { get_coinjoin_keys . call (o_0 , o_1) } , context) ; ferment :: boxed (obj) } } pub mod keychain { use crate as example_entry_point ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`KeyChainKey`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum example_entry_point_keychain_KeyChainKey { StandaloneInfoDictionaryLocationString { extended_public_key_identifier : * mut std :: os :: raw :: c_char } , StandaloneExtendedPublicKeyLocationString { extended_public_key_identifier : * mut std :: os :: raw :: c_char } , HasKnownBalanceUniqueIDString { reference : u32 , unique_id : * mut std :: os :: raw :: c_char } , WalletBasedExtendedPrivateKeyLocationString { unique_id : * mut std :: os :: raw :: c_char } , WalletBasedExtendedPublicKeyLocationString { unique_id : * mut std :: os :: raw :: c_char } } impl ferment :: FFIConversionFrom < example_entry_point :: keychain :: KeyChainKey > for example_entry_point_keychain_KeyChainKey { unsafe fn ffi_from_const (ffi : * const example_entry_point_keychain_KeyChainKey) -> example_entry_point :: keychain :: KeyChainKey { let ffi_ref = & * ffi ; match ffi_ref { example_entry_point_keychain_KeyChainKey :: StandaloneInfoDictionaryLocationString { extended_public_key_identifier } => example_entry_point :: keychain :: KeyChainKey :: StandaloneInfoDictionaryLocationString { extended_public_key_identifier : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* extended_public_key_identifier) } , example_entry_point_keychain_KeyChainKey :: StandaloneExtendedPublicKeyLocationString { extended_public_key_identifier } => example_entry_point :: keychain :: KeyChainKey :: StandaloneExtendedPublicKeyLocationString { extended_public_key_identifier : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* extended_public_key_identifier) } , example_entry_point_keychain_KeyChainKey :: HasKnownBalanceUniqueIDString { reference , unique_id } => example_entry_point :: keychain :: KeyChainKey :: HasKnownBalanceUniqueIDString { reference : * reference , unique_id : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* unique_id) } , example_entry_point_keychain_KeyChainKey :: WalletBasedExtendedPrivateKeyLocationString { unique_id } => example_entry_point :: keychain :: KeyChainKey :: WalletBasedExtendedPrivateKeyLocationString { unique_id : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* unique_id) } , example_entry_point_keychain_KeyChainKey :: WalletBasedExtendedPublicKeyLocationString { unique_id } => example_entry_point :: keychain :: KeyChainKey :: WalletBasedExtendedPublicKeyLocationString { unique_id : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* unique_id) } } } } impl ferment :: FFIConversionTo < example_entry_point :: keychain :: KeyChainKey > for example_entry_point_keychain_KeyChainKey { unsafe fn ffi_to_const (obj : example_entry_point :: keychain :: KeyChainKey) -> * const example_entry_point_keychain_KeyChainKey { ferment :: boxed (match obj { example_entry_point :: keychain :: KeyChainKey :: StandaloneInfoDictionaryLocationString { extended_public_key_identifier } => example_entry_point_keychain_KeyChainKey :: StandaloneInfoDictionaryLocationString { extended_public_key_identifier : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (extended_public_key_identifier) } , example_entry_point :: keychain :: KeyChainKey :: StandaloneExtendedPublicKeyLocationString { extended_public_key_identifier } => example_entry_point_keychain_KeyChainKey :: StandaloneExtendedPublicKeyLocationString { extended_public_key_identifier : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (extended_public_key_identifier) } , example_entry_point :: keychain :: KeyChainKey :: HasKnownBalanceUniqueIDString { reference , unique_id } => example_entry_point_keychain_KeyChainKey :: HasKnownBalanceUniqueIDString { reference : reference , unique_id : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (unique_id) } , example_entry_point :: keychain :: KeyChainKey :: WalletBasedExtendedPrivateKeyLocationString { unique_id } => example_entry_point_keychain_KeyChainKey :: WalletBasedExtendedPrivateKeyLocationString { unique_id : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (unique_id) } , example_entry_point :: keychain :: KeyChainKey :: WalletBasedExtendedPublicKeyLocationString { unique_id } => example_entry_point_keychain_KeyChainKey :: WalletBasedExtendedPublicKeyLocationString { unique_id : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (unique_id) } , _ => unreachable ! ("This is unreachable") }) } } impl Drop for example_entry_point_keychain_KeyChainKey { fn drop (& mut self) { unsafe { match self { example_entry_point_keychain_KeyChainKey :: StandaloneInfoDictionaryLocationString { extended_public_key_identifier } => { ferment :: unbox_string (* extended_public_key_identifier) ; } , example_entry_point_keychain_KeyChainKey :: StandaloneExtendedPublicKeyLocationString { extended_public_key_identifier } => { ferment :: unbox_string (* extended_public_key_identifier) ; } , example_entry_point_keychain_KeyChainKey :: HasKnownBalanceUniqueIDString { reference , unique_id } => { ; ; ferment :: unbox_string (* unique_id) ; } , example_entry_point_keychain_KeyChainKey :: WalletBasedExtendedPrivateKeyLocationString { unique_id } => { ferment :: unbox_string (* unique_id) ; } , example_entry_point_keychain_KeyChainKey :: WalletBasedExtendedPublicKeyLocationString { unique_id } => { ferment :: unbox_string (* unique_id) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn example_entry_point_keychain_KeyChainKey_StandaloneInfoDictionaryLocationString_ctor (extended_public_key_identifier : * mut std :: os :: raw :: c_char) -> * mut example_entry_point_keychain_KeyChainKey { ferment :: boxed (example_entry_point_keychain_KeyChainKey :: StandaloneInfoDictionaryLocationString { extended_public_key_identifier }) } # [no_mangle] pub unsafe extern "C" fn example_entry_point_keychain_KeyChainKey_StandaloneExtendedPublicKeyLocationString_ctor (extended_public_key_identifier : * mut std :: os :: raw :: c_char) -> * mut example_entry_point_keychain_KeyChainKey { ferment :: boxed (example_entry_point_keychain_KeyChainKey :: StandaloneExtendedPublicKeyLocationString { extended_public_key_identifier }) } # [no_mangle] pub unsafe extern "C" fn example_entry_point_keychain_KeyChainKey_HasKnownBalanceUniqueIDString_ctor (reference : u32 , unique_id : * mut std :: os :: raw :: c_char) -> * mut example_entry_point_keychain_KeyChainKey { ferment :: boxed (example_entry_point_keychain_KeyChainKey :: HasKnownBalanceUniqueIDString { reference , unique_id }) } # [no_mangle] pub unsafe extern "C" fn example_entry_point_keychain_KeyChainKey_WalletBasedExtendedPrivateKeyLocationString_ctor (unique_id : * mut std :: os :: raw :: c_char) -> * mut example_entry_point_keychain_KeyChainKey { ferment :: boxed (example_entry_point_keychain_KeyChainKey :: WalletBasedExtendedPrivateKeyLocationString { unique_id }) } # [no_mangle] pub unsafe extern "C" fn example_entry_point_keychain_KeyChainKey_WalletBasedExtendedPublicKeyLocationString_ctor (unique_id : * mut std :: os :: raw :: c_char) -> * mut example_entry_point_keychain_KeyChainKey { ferment :: boxed (example_entry_point_keychain_KeyChainKey :: WalletBasedExtendedPublicKeyLocationString { unique_id }) } # [no_mangle] pub unsafe extern "C" fn example_entry_point_keychain_KeyChainKey_destroy < > (ffi : * mut example_entry_point_keychain_KeyChainKey) { ferment :: unbox_any (ffi) ; } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`KeyChainValue`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum example_entry_point_keychain_KeyChainValue { Bytes (* mut crate :: fermented :: generics :: Vec_u8) , Int64 (i64) , String (* mut std :: os :: raw :: c_char) } impl ferment :: FFIConversionFrom < example_entry_point :: keychain :: KeyChainValue > for example_entry_point_keychain_KeyChainValue { unsafe fn ffi_from_const (ffi : * const example_entry_point_keychain_KeyChainValue) -> example_entry_point :: keychain :: KeyChainValue { let ffi_ref = & * ffi ; match ffi_ref { example_entry_point_keychain_KeyChainValue :: Bytes (o_0) => example_entry_point :: keychain :: KeyChainValue :: Bytes (< crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from (* o_0)) , example_entry_point_keychain_KeyChainValue :: Int64 (o_0) => example_entry_point :: keychain :: KeyChainValue :: Int64 (* o_0) , example_entry_point_keychain_KeyChainValue :: String (o_0) => example_entry_point :: keychain :: KeyChainValue :: String (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < example_entry_point :: keychain :: KeyChainValue > for example_entry_point_keychain_KeyChainValue { unsafe fn ffi_to_const (obj : example_entry_point :: keychain :: KeyChainValue) -> * const example_entry_point_keychain_KeyChainValue { ferment :: boxed (match obj { example_entry_point :: keychain :: KeyChainValue :: Bytes (o_0) => example_entry_point_keychain_KeyChainValue :: Bytes (< crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionTo < Vec < u8 > >> :: ffi_to (o_0)) , example_entry_point :: keychain :: KeyChainValue :: Int64 (o_0) => example_entry_point_keychain_KeyChainValue :: Int64 (o_0) , example_entry_point :: keychain :: KeyChainValue :: String (o_0) => example_entry_point_keychain_KeyChainValue :: String (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for example_entry_point_keychain_KeyChainValue { fn drop (& mut self) { unsafe { match self { example_entry_point_keychain_KeyChainValue :: Bytes (o_0) => { ferment :: unbox_any (* o_0) ; } , example_entry_point_keychain_KeyChainValue :: Int64 (o_0) => { ; } , example_entry_point_keychain_KeyChainValue :: String (o_0) => { ferment :: unbox_string (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn example_entry_point_keychain_KeyChainValue_Bytes_ctor (o_o_0 : * mut crate :: fermented :: generics :: Vec_u8) -> * mut example_entry_point_keychain_KeyChainValue { ferment :: boxed (example_entry_point_keychain_KeyChainValue :: Bytes (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn example_entry_point_keychain_KeyChainValue_Int64_ctor (o_o_0 : i64) -> * mut example_entry_point_keychain_KeyChainValue { ferment :: boxed (example_entry_point_keychain_KeyChainValue :: Int64 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn example_entry_point_keychain_KeyChainValue_String_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut example_entry_point_keychain_KeyChainValue { ferment :: boxed (example_entry_point_keychain_KeyChainValue :: String (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn example_entry_point_keychain_KeyChainValue_destroy < > (ffi : * mut example_entry_point_keychain_KeyChainValue) { ferment :: unbox_any (ffi) ; } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`KeyChainError`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum example_entry_point_keychain_KeyChainError { OsStatusCode (i32) } impl ferment :: FFIConversionFrom < example_entry_point :: keychain :: KeyChainError > for example_entry_point_keychain_KeyChainError { unsafe fn ffi_from_const (ffi : * const example_entry_point_keychain_KeyChainError) -> example_entry_point :: keychain :: KeyChainError { let ffi_ref = & * ffi ; match ffi_ref { example_entry_point_keychain_KeyChainError :: OsStatusCode (o_0) => example_entry_point :: keychain :: KeyChainError :: OsStatusCode (* o_0) } } } impl ferment :: FFIConversionTo < example_entry_point :: keychain :: KeyChainError > for example_entry_point_keychain_KeyChainError { unsafe fn ffi_to_const (obj : example_entry_point :: keychain :: KeyChainError) -> * const example_entry_point_keychain_KeyChainError { ferment :: boxed (match obj { example_entry_point :: keychain :: KeyChainError :: OsStatusCode (o_0) => example_entry_point_keychain_KeyChainError :: OsStatusCode (o_0) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for example_entry_point_keychain_KeyChainError { fn drop (& mut self) { unsafe { match self { example_entry_point_keychain_KeyChainError :: OsStatusCode (o_0) => { ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn example_entry_point_keychain_KeyChainError_OsStatusCode_ctor (o_o_0 : i32) -> * mut example_entry_point_keychain_KeyChainError { ferment :: boxed (example_entry_point_keychain_KeyChainError :: OsStatusCode (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn example_entry_point_keychain_KeyChainError_destroy < > (ffi : * mut example_entry_point_keychain_KeyChainError) { ferment :: unbox_any (ffi) ; } # [doc = "FFI-representation of the [`example_entry_point::keychain::KeychainController::new`]"] # [no_mangle] pub unsafe extern "C" fn example_entry_point_keychain_KeychainController_new (get : crate :: fermented :: generics :: Fn_ARGS_std_os_raw_c_void_example_entry_point_keychain_KeyChainKey_RTRN_Result_ok_example_entry_point_keychain_KeyChainValue_err_example_entry_point_keychain_KeyChainError , set : crate :: fermented :: generics :: Fn_ARGS_std_os_raw_c_void_example_entry_point_keychain_KeyChainKey_example_entry_point_keychain_KeyChainValue_bool_RTRN_Result_ok_bool_err_example_entry_point_keychain_KeyChainError , has : crate :: fermented :: generics :: Fn_ARGS_std_os_raw_c_void_example_entry_point_keychain_KeyChainKey_RTRN_Result_ok_bool_err_example_entry_point_keychain_KeyChainError , delete : crate :: fermented :: generics :: Fn_ARGS_std_os_raw_c_void_example_entry_point_keychain_KeyChainKey_RTRN_Result_ok_bool_err_example_entry_point_keychain_KeyChainError) -> * mut example_entry_point :: keychain :: KeychainController { let obj = example_entry_point :: keychain :: KeychainController :: new (move | o_0 , o_1 | unsafe { get . call (o_0 , o_1) } , move | o_0 , o_1 , o_2 , o_3 | unsafe { set . call (o_0 , o_1 , o_2 , o_3) } , move | o_0 , o_1 | unsafe { has . call (o_0 , o_1) } , move | o_0 , o_1 | unsafe { delete . call (o_0 , o_1) }) ; ferment :: boxed (obj) } # [doc = "FFI-representation of the [`example_entry_point::keychain::KeychainController::get`]"] # [no_mangle] pub unsafe extern "C" fn example_entry_point_keychain_KeychainController_get (self_ : * mut example_entry_point :: keychain :: KeychainController , key : * mut crate :: fermented :: types :: example_entry_point :: keychain :: example_entry_point_keychain_KeyChainKey) -> * mut crate :: fermented :: generics :: Result_ok_example_entry_point_keychain_KeyChainValue_err_example_entry_point_keychain_KeyChainError { let obj = example_entry_point :: keychain :: KeychainController :: get (& * self_ , < crate :: fermented :: types :: example_entry_point :: keychain :: example_entry_point_keychain_KeyChainKey as ferment :: FFIConversionFrom < example_entry_point :: keychain :: KeyChainKey >> :: ffi_from (key)) ; < crate :: fermented :: generics :: Result_ok_example_entry_point_keychain_KeyChainValue_err_example_entry_point_keychain_KeyChainError as ferment :: FFIConversionTo < Result < example_entry_point :: keychain :: KeyChainValue , example_entry_point :: keychain :: KeyChainError > >> :: ffi_to (obj) } # [doc = "FFI-representation of the [`example_entry_point::keychain::KeychainController::set`]"] # [no_mangle] pub unsafe extern "C" fn example_entry_point_keychain_KeychainController_set (self_ : * mut example_entry_point :: keychain :: KeychainController , key : * mut crate :: fermented :: types :: example_entry_point :: keychain :: example_entry_point_keychain_KeyChainKey , value : * mut crate :: fermented :: types :: example_entry_point :: keychain :: example_entry_point_keychain_KeyChainValue , authenticated : bool) -> * mut crate :: fermented :: generics :: Result_ok_bool_err_example_entry_point_keychain_KeyChainError { let obj = example_entry_point :: keychain :: KeychainController :: set (& * self_ , < crate :: fermented :: types :: example_entry_point :: keychain :: example_entry_point_keychain_KeyChainKey as ferment :: FFIConversionFrom < example_entry_point :: keychain :: KeyChainKey >> :: ffi_from (key) , < crate :: fermented :: types :: example_entry_point :: keychain :: example_entry_point_keychain_KeyChainValue as ferment :: FFIConversionFrom < example_entry_point :: keychain :: KeyChainValue >> :: ffi_from (value) , authenticated) ; < crate :: fermented :: generics :: Result_ok_bool_err_example_entry_point_keychain_KeyChainError as ferment :: FFIConversionTo < Result < bool , example_entry_point :: keychain :: KeyChainError > >> :: ffi_to (obj) } # [doc = "FFI-representation of the [`example_entry_point::keychain::KeychainController::has`]"] # [no_mangle] pub unsafe extern "C" fn example_entry_point_keychain_KeychainController_has (self_ : * mut example_entry_point :: keychain :: KeychainController , key : * mut crate :: fermented :: types :: example_entry_point :: keychain :: example_entry_point_keychain_KeyChainKey) -> * mut crate :: fermented :: generics :: Result_ok_bool_err_example_entry_point_keychain_KeyChainError { let obj = example_entry_point :: keychain :: KeychainController :: has (& * self_ , < crate :: fermented :: types :: example_entry_point :: keychain :: example_entry_point_keychain_KeyChainKey as ferment :: FFIConversionFrom < example_entry_point :: keychain :: KeyChainKey >> :: ffi_from (key)) ; < crate :: fermented :: generics :: Result_ok_bool_err_example_entry_point_keychain_KeyChainError as ferment :: FFIConversionTo < Result < bool , example_entry_point :: keychain :: KeyChainError > >> :: ffi_to (obj) } # [doc = "FFI-representation of the [`example_entry_point::keychain::KeychainController::delete`]"] # [no_mangle] pub unsafe extern "C" fn example_entry_point_keychain_KeychainController_delete (self_ : * mut example_entry_point :: keychain :: KeychainController , key : * mut crate :: fermented :: types :: example_entry_point :: keychain :: example_entry_point_keychain_KeyChainKey) -> * mut crate :: fermented :: generics :: Result_ok_bool_err_example_entry_point_keychain_KeyChainError { let obj = example_entry_point :: keychain :: KeychainController :: delete (& * self_ , < crate :: fermented :: types :: example_entry_point :: keychain :: example_entry_point_keychain_KeyChainKey as ferment :: FFIConversionFrom < example_entry_point :: keychain :: KeyChainKey >> :: ffi_from (key)) ; < crate :: fermented :: generics :: Result_ok_bool_err_example_entry_point_keychain_KeyChainError as ferment :: FFIConversionTo < Result < bool , example_entry_point :: keychain :: KeyChainError > >> :: ffi_to (obj) } # [doc = "FFI-representation of the [`example_entry_point::keychain::KeychainController::mark_already_joined_queue_as_tried`]"] # [no_mangle] pub unsafe extern "C" fn example_entry_point_keychain_KeychainController_mark_already_joined_queue_as_tried (self_ : * mut example_entry_point :: keychain :: KeychainController , _dsq : * mut crate :: fermented :: types :: example_entry_point :: keychain :: example_entry_point_keychain_KeyChainKey) -> bool { let obj = example_entry_point :: keychain :: KeychainController :: mark_already_joined_queue_as_tried (& mut * self_ , Box :: leak (Box :: new (< crate :: fermented :: types :: example_entry_point :: keychain :: example_entry_point_keychain_KeyChainKey as ferment :: FFIConversionFrom < example_entry_point :: keychain :: KeyChainKey >> :: ffi_from (_dsq)))) ; obj } } pub mod custom { use crate as example_entry_point ; } pub mod entry { use crate as example_entry_point ; # [doc = "FFI-representation of the [`example_entry_point::entry::PlatformProvider::new`]"] # [no_mangle] pub unsafe extern "C" fn example_entry_point_entry_PlatformProvider_new (get_quorum_public_key : crate :: fermented :: generics :: Fn_ARGS_example_entry_point_entry_FFIContext_u32_Arr_u8_32_u32_RTRN_Result_ok_u8_arr_48_err_String , get_data_contract : crate :: fermented :: generics :: Fn_ARGS_example_entry_point_entry_FFIContext_String_RTRN_Result_ok_Option_std_sync_Arc_example_entry_point_entry_SomeModel_err_String , context : * mut crate :: fermented :: generics :: std_sync_Arc_example_entry_point_entry_FFIContext) -> * mut example_entry_point :: entry :: PlatformProvider { let obj = example_entry_point :: entry :: PlatformProvider :: new (move | o_0 , o_1 , o_2 , o_3 | unsafe { get_quorum_public_key . call (o_0 , o_1 , o_2 , o_3) } , move | o_0 , o_1 | unsafe { get_data_contract . call (o_0 , o_1) } , < crate :: fermented :: generics :: std_sync_Arc_example_entry_point_entry_FFIContext as ferment :: FFIConversionFrom < std :: sync :: Arc < example_entry_point :: entry :: FFIContext > >> :: ffi_from (context)) ; ferment :: boxed (obj) } pub mod rnt { use crate as example_entry_point ; # [doc = "FFI-representation of the [`example_entry_point::entry::rnt::DashSharedCoreWithRuntime::with_pointers`]"] # [no_mangle] pub unsafe extern "C" fn example_entry_point_entry_rnt_DashSharedCoreWithRuntime_with_pointers (block_hash_by_height : example_entry_point :: entry :: BlockHashByHeight , model_by_height : example_entry_point :: entry :: ModelByHeight , runtime : * mut tokio :: runtime :: Runtime , context : * const std :: os :: raw :: c_void) -> * mut example_entry_point :: entry :: rnt :: DashSharedCoreWithRuntime { let obj = example_entry_point :: entry :: rnt :: DashSharedCoreWithRuntime :: with_pointers (block_hash_by_height , model_by_height , runtime , context) ; ferment :: boxed (obj) } # [doc = "FFI-representation of the [`example_entry_point::entry::rnt::DashSharedCoreWithRuntime::with_lambdas`]"] # [no_mangle] pub unsafe extern "C" fn example_entry_point_entry_rnt_DashSharedCoreWithRuntime_with_lambdas (block_hash_by_height : crate :: fermented :: generics :: Fn_ARGS_u32_RTRN_Arr_u8_32 , model_by_height : crate :: fermented :: generics :: Fn_ARGS_u32_RTRN_example_entry_point_entry_SomeModel , runtime : * mut tokio :: runtime :: Runtime , context : * const std :: os :: raw :: c_void) -> * mut example_entry_point :: entry :: rnt :: DashSharedCoreWithRuntime { let obj = example_entry_point :: entry :: rnt :: DashSharedCoreWithRuntime :: with_lambdas (move | o_0 | unsafe { block_hash_by_height . call (o_0) } , move | o_0 | unsafe { model_by_height . call (o_0) } , runtime , context) ; ferment :: boxed (obj) } } pub mod core { use crate as example_entry_point ; # [doc = "FFI-representation of the [`example_entry_point::entry::core::DashSharedCore::with_pointers`]"] # [no_mangle] pub unsafe extern "C" fn example_entry_point_entry_core_DashSharedCore_with_pointers (block_hash_by_height : example_entry_point :: entry :: BlockHashByHeight , model_by_height : example_entry_point :: entry :: ModelByHeight , context : * const std :: os :: raw :: c_void) -> * mut example_entry_point :: entry :: core :: DashSharedCore { let obj = example_entry_point :: entry :: core :: DashSharedCore :: with_pointers (block_hash_by_height , model_by_height , context) ; ferment :: boxed (obj) } # [doc = "FFI-representation of the [`example_entry_point::entry::core::DashSharedCore::with_lambdas`]"] # [no_mangle] pub unsafe extern "C" fn example_entry_point_entry_core_DashSharedCore_with_lambdas (block_hash_by_height : crate :: fermented :: generics :: Fn_ARGS_u32_RTRN_Arr_u8_32 , model_by_height : crate :: fermented :: generics :: Fn_ARGS_u32_RTRN_example_entry_point_entry_SomeModel , context : * const std :: os :: raw :: c_void) -> * mut example_entry_point :: entry :: core :: DashSharedCore { let obj = example_entry_point :: entry :: core :: DashSharedCore :: with_lambdas (move | o_0 | unsafe { block_hash_by_height . call (o_0) } , move | o_0 | unsafe { model_by_height . call (o_0) } , context) ; ferment :: boxed (obj) } } pub mod provider { use crate as example_entry_point ; } pub mod processor { use crate as example_entry_point ; } # [doc = "FFI-representation of the [`SomeModel`]"] # [repr (C)] # [derive (Clone)] pub struct example_entry_point_entry_SomeModel { pub hash : * mut crate :: fermented :: generics :: Arr_u8_32 , pub desc : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < example_entry_point :: entry :: SomeModel > for example_entry_point_entry_SomeModel { unsafe fn ffi_from_const (ffi : * const example_entry_point_entry_SomeModel) -> example_entry_point :: entry :: SomeModel { let ffi_ref = & * ffi ; example_entry_point :: entry :: SomeModel { hash : < crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionFrom < [u8 ; 32] >> :: ffi_from (ffi_ref . hash) , desc : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . desc) } } } impl ferment :: FFIConversionTo < example_entry_point :: entry :: SomeModel > for example_entry_point_entry_SomeModel { unsafe fn ffi_to_const (obj : example_entry_point :: entry :: SomeModel) -> * const example_entry_point_entry_SomeModel { ferment :: boxed (example_entry_point_entry_SomeModel { hash : < crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionTo < [u8 ; 32] >> :: ffi_to (obj . hash) , desc : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . desc) }) } } impl Drop for example_entry_point_entry_SomeModel { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . hash) ; ferment :: unbox_string (ffi_ref . desc) ; } } } # [no_mangle] pub unsafe extern "C" fn example_entry_point_entry_SomeModel_ctor < > (hash : * mut crate :: fermented :: generics :: Arr_u8_32 , desc : * mut std :: os :: raw :: c_char) -> * mut example_entry_point_entry_SomeModel { ferment :: boxed (example_entry_point_entry_SomeModel { hash , desc }) } # [no_mangle] pub unsafe extern "C" fn example_entry_point_entry_SomeModel_destroy < > (ffi : * mut example_entry_point_entry_SomeModel) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn example_entry_point_entry_SomeModel_get_hash < > (obj : * const example_entry_point_entry_SomeModel) -> * mut crate :: fermented :: generics :: Arr_u8_32 { (* obj) . hash } # [no_mangle] pub unsafe extern "C" fn example_entry_point_entry_SomeModel_get_desc < > (obj : * const example_entry_point_entry_SomeModel) -> * mut std :: os :: raw :: c_char { (* obj) . desc } # [no_mangle] pub unsafe extern "C" fn example_entry_point_entry_SomeModel_set_hash < > (obj : * const example_entry_point_entry_SomeModel) -> * mut crate :: fermented :: generics :: Arr_u8_32 { (* obj) . hash } # [no_mangle] pub unsafe extern "C" fn example_entry_point_entry_SomeModel_set_desc < > (obj : * const example_entry_point_entry_SomeModel) -> * mut std :: os :: raw :: c_char { (* obj) . desc } } pub mod wallet { use crate as example_entry_point ; # [doc = "FFI-representation of the [`example_entry_point::wallet::WalletEx::new`]"] # [no_mangle] pub unsafe extern "C" fn example_entry_point_wallet_WalletEx_new (context : * const std :: os :: raw :: c_void , options : * mut crate :: fermented :: generics :: std_rc_Rc_std_cell_RefCell_u8_32 , get_wallet_transaction : crate :: fermented :: generics :: Fn_ARGS_std_os_raw_c_void_Arr_u8_32_RTRN_Option_u8_32 , sign_transaction : crate :: fermented :: generics :: Fn_ARGS_std_os_raw_c_void_Arr_u8_32_bool_RTRN_Option_u8_32 , is_mine_input : crate :: fermented :: generics :: Fn_ARGS_std_os_raw_c_void_Arr_u8_32_RTRN_bool , available_coins : crate :: fermented :: generics :: Fn_ARGS_std_os_raw_c_void_bool_Arr_u8_32_example_entry_point_wallet_WalletEx_RTRN_Vec_u8_32 , select_coins : crate :: fermented :: generics :: Fn_ARGS_std_os_raw_c_void_bool_bool_bool_i32_RTRN_Vec_u8_32 , inputs_with_amount : crate :: fermented :: generics :: Fn_ARGS_std_os_raw_c_void_u64_RTRN_u32 , fresh_coinjoin_address : crate :: fermented :: generics :: Fn_ARGS_std_os_raw_c_void_bool_RTRN_Vec_u8 , commit_transaction : crate :: fermented :: generics :: Fn_ARGS_std_os_raw_c_void_Vec_u8_32_Arr_u8_32_bool_Arr_u8_32_RTRN_bool , is_synced : crate :: fermented :: generics :: Fn_ARGS_std_os_raw_c_void_RTRN_bool , is_masternode_or_disconnect_requested : crate :: fermented :: generics :: Fn_ARGS_std_os_raw_c_void_String_RTRN_bool , disconnect_masternode : crate :: fermented :: generics :: Fn_ARGS_std_os_raw_c_void_std_net_SocketAddr_RTRN_bool , send_message : crate :: fermented :: generics :: Fn_ARGS_std_os_raw_c_void_String_Vec_u8_Option_std_net_SocketAddr_bool_RTRN_bool , add_pending_masternode : crate :: fermented :: generics :: Fn_ARGS_std_os_raw_c_void_Arr_u8_32_Arr_u8_32_RTRN_bool , start_manager_async : crate :: fermented :: generics :: Fn_ARGS_std_os_raw_c_void_RTRN_ , get_coinjoin_keys : crate :: fermented :: generics :: Fn_ARGS_std_os_raw_c_void_bool_RTRN_Vec_Vec_u8) -> * mut example_entry_point :: wallet :: WalletEx { let obj = example_entry_point :: wallet :: WalletEx :: new (context , < crate :: fermented :: generics :: std_rc_Rc_std_cell_RefCell_u8_32 as ferment :: FFIConversionFrom < std :: rc :: Rc < std :: cell :: RefCell < [u8 ; 32] > > >> :: ffi_from (options) , move | o_0 , o_1 | unsafe { get_wallet_transaction . call (o_0 , o_1) } , move | o_0 , o_1 , o_2 | unsafe { sign_transaction . call (o_0 , o_1 , o_2) } , move | o_0 , o_1 | unsafe { is_mine_input . call (o_0 , o_1) } , move | o_0 , o_1 , o_2 , o_3 | unsafe { available_coins . call (o_0 , o_1 , o_2 , o_3) } , move | o_0 , o_1 , o_2 , o_3 , o_4 | unsafe { select_coins . call (o_0 , o_1 , o_2 , o_3 , o_4) } , move | o_0 , o_1 | unsafe { inputs_with_amount . call (o_0 , o_1) } , move | o_0 , o_1 | unsafe { fresh_coinjoin_address . call (o_0 , o_1) } , move | o_0 , o_1 , o_2 , o_3 , o_4 | unsafe { commit_transaction . call (o_0 , o_1 , o_2 , o_3 , o_4) } , move | o_0 | unsafe { is_synced . call (o_0) } , move | o_0 , o_1 | unsafe { is_masternode_or_disconnect_requested . call (o_0 , o_1) } , move | o_0 , o_1 | unsafe { disconnect_masternode . call (o_0 , o_1) } , move | o_0 , o_1 , o_2 , o_3 , o_4 | unsafe { send_message . call (o_0 , o_1 , o_2 , o_3 , o_4) } , move | o_0 , o_1 , o_2 | unsafe { add_pending_masternode . call (o_0 , o_1 , o_2) } , move | o_0 | unsafe { start_manager_async . call (o_0) } , move | o_0 , o_1 | unsafe { get_coinjoin_keys . call (o_0 , o_1) }) ; ferment :: boxed (obj) } } } } # [allow (clippy :: let_and_return , clippy :: suspicious_else_formatting , clippy :: redundant_field_names , dead_code , non_camel_case_types , non_snake_case , non_upper_case_globals , redundant_semicolons , unreachable_patterns , unused_braces , unused_imports , unused_parens , unused_qualifications , unused_unsafe , unused_variables)] pub mod generics { use crate as example_entry_point ; # [repr (C)] # [derive (Clone)] pub struct Fn_ARGS_std_os_raw_c_void_u64_RTRN_u32 { caller : unsafe extern "C" fn (* const std :: os :: raw :: c_void , u64) -> u32 , destructor : unsafe extern "C" fn (u32) } impl Fn_ARGS_std_os_raw_c_void_u64_RTRN_u32 { pub unsafe fn call (& self , o_0 : * const std :: os :: raw :: c_void , o_1 : u64) -> u32 { let ffi_result = (self . caller) (o_0 , o_1) ; ffi_result } } unsafe impl Send for Fn_ARGS_std_os_raw_c_void_u64_RTRN_u32 { } unsafe impl Sync for Fn_ARGS_std_os_raw_c_void_u64_RTRN_u32 { } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_std_os_raw_c_void_u64_RTRN_u32_ctor (caller : unsafe extern "C" fn (* const std :: os :: raw :: c_void , u64) -> u32 , destructor : unsafe extern "C" fn (u32)) -> * mut Fn_ARGS_std_os_raw_c_void_u64_RTRN_u32 { ferment :: boxed (Fn_ARGS_std_os_raw_c_void_u64_RTRN_u32 { caller , destructor }) } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_std_os_raw_c_void_u64_RTRN_u32_destroy (ffi : * mut Fn_ARGS_std_os_raw_c_void_u64_RTRN_u32) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Fn_ARGS_std_os_raw_c_void_bool_RTRN_Vec_Vec_u8 { caller : unsafe extern "C" fn (* const std :: os :: raw :: c_void , bool) -> * mut crate :: fermented :: generics :: Vec_Vec_u8 , destructor : unsafe extern "C" fn (* mut crate :: fermented :: generics :: Vec_Vec_u8) } impl Fn_ARGS_std_os_raw_c_void_bool_RTRN_Vec_Vec_u8 { pub unsafe fn call (& self , o_0 : * const std :: os :: raw :: c_void , o_1 : bool) -> Vec < Vec < u8 > > { let ffi_result = (self . caller) (o_0 , o_1) ; let result = < crate :: fermented :: generics :: Vec_Vec_u8 as ferment :: FFIConversionFrom < Vec < Vec < u8 > > >> :: ffi_from (ffi_result) ; (self . destructor) (ffi_result) ; result } } unsafe impl Send for Fn_ARGS_std_os_raw_c_void_bool_RTRN_Vec_Vec_u8 { } unsafe impl Sync for Fn_ARGS_std_os_raw_c_void_bool_RTRN_Vec_Vec_u8 { } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_std_os_raw_c_void_bool_RTRN_Vec_Vec_u8_ctor (caller : unsafe extern "C" fn (* const std :: os :: raw :: c_void , bool) -> * mut crate :: fermented :: generics :: Vec_Vec_u8 , destructor : unsafe extern "C" fn (* mut crate :: fermented :: generics :: Vec_Vec_u8)) -> * mut Fn_ARGS_std_os_raw_c_void_bool_RTRN_Vec_Vec_u8 { ferment :: boxed (Fn_ARGS_std_os_raw_c_void_bool_RTRN_Vec_Vec_u8 { caller , destructor }) } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_std_os_raw_c_void_bool_RTRN_Vec_Vec_u8_destroy (ffi : * mut Fn_ARGS_std_os_raw_c_void_bool_RTRN_Vec_Vec_u8) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Fn_ARGS_std_os_raw_c_void_example_entry_point_keychain_KeyChainKey_example_entry_point_keychain_KeyChainValue_bool_RTRN_Result_ok_bool_err_example_entry_point_keychain_KeyChainError { caller : unsafe extern "C" fn (* const std :: os :: raw :: c_void , * mut crate :: fermented :: types :: example_entry_point :: keychain :: example_entry_point_keychain_KeyChainKey , * mut crate :: fermented :: types :: example_entry_point :: keychain :: example_entry_point_keychain_KeyChainValue , bool) -> * mut crate :: fermented :: generics :: Result_ok_bool_err_example_entry_point_keychain_KeyChainError , destructor : unsafe extern "C" fn (* mut crate :: fermented :: generics :: Result_ok_bool_err_example_entry_point_keychain_KeyChainError) } impl Fn_ARGS_std_os_raw_c_void_example_entry_point_keychain_KeyChainKey_example_entry_point_keychain_KeyChainValue_bool_RTRN_Result_ok_bool_err_example_entry_point_keychain_KeyChainError { pub unsafe fn call (& self , o_0 : * const std :: os :: raw :: c_void , o_1 : example_entry_point :: keychain :: KeyChainKey , o_2 : example_entry_point :: keychain :: KeyChainValue , o_3 : bool) -> Result < bool , example_entry_point :: keychain :: KeyChainError > { let ffi_result = (self . caller) (o_0 , < crate :: fermented :: types :: example_entry_point :: keychain :: example_entry_point_keychain_KeyChainKey as ferment :: FFIConversionTo < example_entry_point :: keychain :: KeyChainKey >> :: ffi_to (o_1) , < crate :: fermented :: types :: example_entry_point :: keychain :: example_entry_point_keychain_KeyChainValue as ferment :: FFIConversionTo < example_entry_point :: keychain :: KeyChainValue >> :: ffi_to (o_2) , o_3) ; let result = < crate :: fermented :: generics :: Result_ok_bool_err_example_entry_point_keychain_KeyChainError as ferment :: FFIConversionFrom < Result < bool , example_entry_point :: keychain :: KeyChainError > >> :: ffi_from (ffi_result) ; (self . destructor) (ffi_result) ; result } } unsafe impl Send for Fn_ARGS_std_os_raw_c_void_example_entry_point_keychain_KeyChainKey_example_entry_point_keychain_KeyChainValue_bool_RTRN_Result_ok_bool_err_example_entry_point_keychain_KeyChainError { } unsafe impl Sync for Fn_ARGS_std_os_raw_c_void_example_entry_point_keychain_KeyChainKey_example_entry_point_keychain_KeyChainValue_bool_RTRN_Result_ok_bool_err_example_entry_point_keychain_KeyChainError { } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_std_os_raw_c_void_example_entry_point_keychain_KeyChainKey_example_entry_point_keychain_KeyChainValue_bool_RTRN_Result_ok_bool_err_example_entry_point_keychain_KeyChainError_ctor (caller : unsafe extern "C" fn (* const std :: os :: raw :: c_void , * mut crate :: fermented :: types :: example_entry_point :: keychain :: example_entry_point_keychain_KeyChainKey , * mut crate :: fermented :: types :: example_entry_point :: keychain :: example_entry_point_keychain_KeyChainValue , bool) -> * mut crate :: fermented :: generics :: Result_ok_bool_err_example_entry_point_keychain_KeyChainError , destructor : unsafe extern "C" fn (* mut crate :: fermented :: generics :: Result_ok_bool_err_example_entry_point_keychain_KeyChainError)) -> * mut Fn_ARGS_std_os_raw_c_void_example_entry_point_keychain_KeyChainKey_example_entry_point_keychain_KeyChainValue_bool_RTRN_Result_ok_bool_err_example_entry_point_keychain_KeyChainError { ferment :: boxed (Fn_ARGS_std_os_raw_c_void_example_entry_point_keychain_KeyChainKey_example_entry_point_keychain_KeyChainValue_bool_RTRN_Result_ok_bool_err_example_entry_point_keychain_KeyChainError { caller , destructor }) } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_std_os_raw_c_void_example_entry_point_keychain_KeyChainKey_example_entry_point_keychain_KeyChainValue_bool_RTRN_Result_ok_bool_err_example_entry_point_keychain_KeyChainError_destroy (ffi : * mut Fn_ARGS_std_os_raw_c_void_example_entry_point_keychain_KeyChainKey_example_entry_point_keychain_KeyChainValue_bool_RTRN_Result_ok_bool_err_example_entry_point_keychain_KeyChainError) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_std_net_SocketAddr_RTRN_bool { pub obj : * mut crate :: fermented :: generics :: Fn_ARGS_std_os_raw_c_void_std_net_SocketAddr_RTRN_bool } impl ferment :: FFIConversionFrom < std :: sync :: Arc < dyn Fn (* const std :: os :: raw :: c_void , std :: net :: SocketAddr) -> bool > > for std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_std_net_SocketAddr_RTRN_bool { unsafe fn ffi_from_const (ffi : * const std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_std_net_SocketAddr_RTRN_bool) -> std :: sync :: Arc < dyn Fn (* const std :: os :: raw :: c_void , std :: net :: SocketAddr) -> bool > { let ffi_ref = & * ffi ; std :: sync :: Arc :: new (move | o_0 , o_1 | unsafe { (& * ffi_ref . obj) . call (o_0 , o_1) }) } } impl Drop for std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_std_net_SocketAddr_RTRN_bool { fn drop (& mut self) { unsafe { ; } } } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_std_net_SocketAddr_RTRN_bool_ctor (obj : * mut crate :: fermented :: generics :: Fn_ARGS_std_os_raw_c_void_std_net_SocketAddr_RTRN_bool) -> * mut std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_std_net_SocketAddr_RTRN_bool { ferment :: boxed (std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_std_net_SocketAddr_RTRN_bool { obj }) } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_std_net_SocketAddr_RTRN_bool_destroy (ffi : * mut std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_std_net_SocketAddr_RTRN_bool) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Result_ok_u8_arr_48_err_String { pub ok : * mut crate :: fermented :: generics :: Arr_u8_48 , pub error : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < Result < [u8 ; 48] , String > > for Result_ok_u8_arr_48_err_String { unsafe fn ffi_from_const (ffi : * const Result_ok_u8_arr_48_err_String) -> Result < [u8 ; 48] , String > { let ffi_ref = & * ffi ; ferment :: fold_to_result (ffi_ref . ok , | o | < crate :: fermented :: generics :: Arr_u8_48 as ferment :: FFIConversionFrom < [u8 ; 48] >> :: ffi_from (o) , ffi_ref . error , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (o)) } } impl ferment :: FFIConversionTo < Result < [u8 ; 48] , String > > for Result_ok_u8_arr_48_err_String { unsafe fn ffi_to_const (obj : Result < [u8 ; 48] , String >) -> * const Result_ok_u8_arr_48_err_String { ferment :: boxed ({ let (ok , error) = ferment :: to_result (obj , | o | ferment :: FFIConversionTo :: ffi_to (o) , | o | ferment :: FFIConversionTo :: ffi_to (o)) ; Self { ok , error } }) } } impl Drop for Result_ok_u8_arr_48_err_String { fn drop (& mut self) { unsafe { ferment :: unbox_any_opt (self . ok) ; ferment :: unbox_any_opt (self . error) ; } } } # [no_mangle] pub unsafe extern "C" fn Result_ok_u8_arr_48_err_String_ctor (ok : * mut crate :: fermented :: generics :: Arr_u8_48 , error : * mut std :: os :: raw :: c_char) -> * mut Result_ok_u8_arr_48_err_String { ferment :: boxed (Result_ok_u8_arr_48_err_String { ok , error }) } # [no_mangle] pub unsafe extern "C" fn Result_ok_u8_arr_48_err_String_destroy (ffi : * mut Result_ok_u8_arr_48_err_String) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_RTRN_ { pub obj : * mut crate :: fermented :: generics :: Fn_ARGS_std_os_raw_c_void_RTRN_ } impl ferment :: FFIConversionFrom < std :: sync :: Arc < dyn Fn (* const std :: os :: raw :: c_void) > > for std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_RTRN_ { unsafe fn ffi_from_const (ffi : * const std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_RTRN_) -> std :: sync :: Arc < dyn Fn (* const std :: os :: raw :: c_void) > { let ffi_ref = & * ffi ; std :: sync :: Arc :: new (move | o_0 | unsafe { (& * ffi_ref . obj) . call (o_0) }) } } impl Drop for std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_RTRN_ { fn drop (& mut self) { unsafe { ; } } } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_RTRN__ctor (obj : * mut crate :: fermented :: generics :: Fn_ARGS_std_os_raw_c_void_RTRN_) -> * mut std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_RTRN_ { ferment :: boxed (std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_RTRN_ { obj }) } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_RTRN__destroy (ffi : * mut std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_RTRN_) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Fn_ARGS_std_os_raw_c_void_String_Vec_u8_Option_std_net_SocketAddr_bool_RTRN_bool { caller : unsafe extern "C" fn (* const std :: os :: raw :: c_void , * mut std :: os :: raw :: c_char , * mut crate :: fermented :: generics :: Vec_u8 , * mut example_entry_point :: custom :: std :: SocketAddr , bool) -> bool , destructor : unsafe extern "C" fn (bool) } impl Fn_ARGS_std_os_raw_c_void_String_Vec_u8_Option_std_net_SocketAddr_bool_RTRN_bool { pub unsafe fn call (& self , o_0 : * const std :: os :: raw :: c_void , o_1 : String , o_2 : Vec < u8 > , o_3 : Option < std :: net :: SocketAddr > , o_4 : bool) -> bool { let ffi_result = (self . caller) (o_0 , < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_1) , < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionTo < Vec < u8 > >> :: ffi_to (o_2) , < example_entry_point :: custom :: std :: SocketAddr as ferment :: FFIConversionTo < std :: net :: SocketAddr >> :: ffi_to_opt (o_3) , o_4) ; ffi_result } } unsafe impl Send for Fn_ARGS_std_os_raw_c_void_String_Vec_u8_Option_std_net_SocketAddr_bool_RTRN_bool { } unsafe impl Sync for Fn_ARGS_std_os_raw_c_void_String_Vec_u8_Option_std_net_SocketAddr_bool_RTRN_bool { } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_std_os_raw_c_void_String_Vec_u8_Option_std_net_SocketAddr_bool_RTRN_bool_ctor (caller : unsafe extern "C" fn (* const std :: os :: raw :: c_void , * mut std :: os :: raw :: c_char , * mut crate :: fermented :: generics :: Vec_u8 , * mut example_entry_point :: custom :: std :: SocketAddr , bool) -> bool , destructor : unsafe extern "C" fn (bool)) -> * mut Fn_ARGS_std_os_raw_c_void_String_Vec_u8_Option_std_net_SocketAddr_bool_RTRN_bool { ferment :: boxed (Fn_ARGS_std_os_raw_c_void_String_Vec_u8_Option_std_net_SocketAddr_bool_RTRN_bool { caller , destructor }) } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_std_os_raw_c_void_String_Vec_u8_Option_std_net_SocketAddr_bool_RTRN_bool_destroy (ffi : * mut Fn_ARGS_std_os_raw_c_void_String_Vec_u8_Option_std_net_SocketAddr_bool_RTRN_bool) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Fn_ARGS_Arr_u8_32_RTRN_u32 { caller : unsafe extern "C" fn (* mut crate :: fermented :: generics :: Arr_u8_32) -> u32 , destructor : unsafe extern "C" fn (u32) } impl Fn_ARGS_Arr_u8_32_RTRN_u32 { pub unsafe fn call (& self , o_0 : [u8 ; 32]) -> u32 { let ffi_result = (self . caller) (< crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionTo < [u8 ; 32] >> :: ffi_to (o_0)) ; ffi_result } } unsafe impl Send for Fn_ARGS_Arr_u8_32_RTRN_u32 { } unsafe impl Sync for Fn_ARGS_Arr_u8_32_RTRN_u32 { } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_Arr_u8_32_RTRN_u32_ctor (caller : unsafe extern "C" fn (* mut crate :: fermented :: generics :: Arr_u8_32) -> u32 , destructor : unsafe extern "C" fn (u32)) -> * mut Fn_ARGS_Arr_u8_32_RTRN_u32 { ferment :: boxed (Fn_ARGS_Arr_u8_32_RTRN_u32 { caller , destructor }) } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_Arr_u8_32_RTRN_u32_destroy (ffi : * mut Fn_ARGS_Arr_u8_32_RTRN_u32) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Fn_ARGS_std_os_raw_c_void_Arr_u8_32_RTRN_bool { caller : unsafe extern "C" fn (* const std :: os :: raw :: c_void , * mut crate :: fermented :: generics :: Arr_u8_32) -> bool , destructor : unsafe extern "C" fn (bool) } impl Fn_ARGS_std_os_raw_c_void_Arr_u8_32_RTRN_bool { pub unsafe fn call (& self , o_0 : * const std :: os :: raw :: c_void , o_1 : [u8 ; 32]) -> bool { let ffi_result = (self . caller) (o_0 , < crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionTo < [u8 ; 32] >> :: ffi_to (o_1)) ; ffi_result } } unsafe impl Send for Fn_ARGS_std_os_raw_c_void_Arr_u8_32_RTRN_bool { } unsafe impl Sync for Fn_ARGS_std_os_raw_c_void_Arr_u8_32_RTRN_bool { } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_std_os_raw_c_void_Arr_u8_32_RTRN_bool_ctor (caller : unsafe extern "C" fn (* const std :: os :: raw :: c_void , * mut crate :: fermented :: generics :: Arr_u8_32) -> bool , destructor : unsafe extern "C" fn (bool)) -> * mut Fn_ARGS_std_os_raw_c_void_Arr_u8_32_RTRN_bool { ferment :: boxed (Fn_ARGS_std_os_raw_c_void_Arr_u8_32_RTRN_bool { caller , destructor }) } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_std_os_raw_c_void_Arr_u8_32_RTRN_bool_destroy (ffi : * mut Fn_ARGS_std_os_raw_c_void_Arr_u8_32_RTRN_bool) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_rc_Rc_std_cell_RefCell_u8_32 { pub obj : * mut crate :: fermented :: generics :: std_cell_RefCell_u8_32 } impl ferment :: FFIConversionFrom < std :: rc :: Rc < std :: cell :: RefCell < [u8 ; 32] > > > for std_rc_Rc_std_cell_RefCell_u8_32 { unsafe fn ffi_from_const (ffi : * const std_rc_Rc_std_cell_RefCell_u8_32) -> std :: rc :: Rc < std :: cell :: RefCell < [u8 ; 32] > > { let ffi_ref = & * ffi ; std :: rc :: Rc :: new (ferment :: FFIConversionFrom :: ffi_from (ffi_ref . obj)) } } impl ferment :: FFIConversionTo < std :: rc :: Rc < std :: cell :: RefCell < [u8 ; 32] > > > for std_rc_Rc_std_cell_RefCell_u8_32 { unsafe fn ffi_to_const (obj : std :: rc :: Rc < std :: cell :: RefCell < [u8 ; 32] > >) -> * const std_rc_Rc_std_cell_RefCell_u8_32 { ferment :: boxed (Self { obj : ferment :: FFIConversionTo :: ffi_to ((* obj) . clone ()) }) } } impl Drop for std_rc_Rc_std_cell_RefCell_u8_32 { fn drop (& mut self) { unsafe { ferment :: unbox_any (self . obj) ; } } } # [no_mangle] pub unsafe extern "C" fn std_rc_Rc_std_cell_RefCell_u8_32_ctor (obj : * mut crate :: fermented :: generics :: std_cell_RefCell_u8_32) -> * mut std_rc_Rc_std_cell_RefCell_u8_32 { ferment :: boxed (std_rc_Rc_std_cell_RefCell_u8_32 { obj }) } # [no_mangle] pub unsafe extern "C" fn std_rc_Rc_std_cell_RefCell_u8_32_destroy (ffi : * mut std_rc_Rc_std_cell_RefCell_u8_32) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_cell_RefCell_u8_32 { pub obj : * mut crate :: fermented :: generics :: Arr_u8_32 } impl ferment :: FFIConversionFrom < std :: cell :: RefCell < [u8 ; 32] > > for std_cell_RefCell_u8_32 { unsafe fn ffi_from_const (ffi : * const std_cell_RefCell_u8_32) -> std :: cell :: RefCell < [u8 ; 32] > { let ffi_ref = & * ffi ; std :: cell :: RefCell :: new (ferment :: FFIConversionFrom :: ffi_from (ffi_ref . obj)) } } impl ferment :: FFIConversionTo < std :: cell :: RefCell < [u8 ; 32] > > for std_cell_RefCell_u8_32 { unsafe fn ffi_to_const (obj : std :: cell :: RefCell < [u8 ; 32] >) -> * const std_cell_RefCell_u8_32 { ferment :: boxed (Self { obj : ferment :: FFIConversionTo :: ffi_to (obj . into_inner ()) }) } } impl Drop for std_cell_RefCell_u8_32 { fn drop (& mut self) { unsafe { ferment :: unbox_any (self . obj) ; } } } # [no_mangle] pub unsafe extern "C" fn std_cell_RefCell_u8_32_ctor (obj : * mut crate :: fermented :: generics :: Arr_u8_32) -> * mut std_cell_RefCell_u8_32 { ferment :: boxed (std_cell_RefCell_u8_32 { obj }) } # [no_mangle] pub unsafe extern "C" fn std_cell_RefCell_u8_32_destroy (ffi : * mut std_cell_RefCell_u8_32) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_collections_Map_keys_String_values_String { pub count : usize , pub keys : * mut * mut std :: os :: raw :: c_char , pub values : * mut * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < std :: collections :: BTreeMap < String , String > > for std_collections_Map_keys_String_values_String { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_String_values_String) -> std :: collections :: BTreeMap < String , String > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (o) , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (o)) } } impl ferment :: FFIConversionTo < std :: collections :: BTreeMap < String , String > > for std_collections_Map_keys_String_values_String { unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < String , String >) -> * const std_collections_Map_keys_String_values_String { ferment :: boxed (Self { count : obj . len () , keys : ferment :: to_complex_group (obj . keys () . cloned ()) , values : ferment :: to_complex_group (obj . values () . cloned ()) }) } } impl Drop for std_collections_Map_keys_String_values_String { fn drop (& mut self) { unsafe { ferment :: unbox_any_vec_ptr_composer (self . keys , self . count , ferment :: unbox_string) ; ferment :: unbox_any_vec_ptr_composer (self . values , self . count , ferment :: unbox_string) ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_String_values_String_ctor (count : usize , keys : * mut * mut std :: os :: raw :: c_char , values : * mut * mut std :: os :: raw :: c_char) -> * mut std_collections_Map_keys_String_values_String { ferment :: boxed (std_collections_Map_keys_String_values_String { count , keys , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_String_values_String_destroy (ffi : * mut std_collections_Map_keys_String_values_String) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Fn_ARGS_std_os_raw_c_void_bool_Arr_u8_32_example_entry_point_wallet_WalletEx_RTRN_Vec_u8_32 { caller : unsafe extern "C" fn (* const std :: os :: raw :: c_void , bool , * mut crate :: fermented :: generics :: Arr_u8_32 , * mut example_entry_point :: wallet :: WalletEx) -> * mut crate :: fermented :: generics :: Vec_u8_32 , destructor : unsafe extern "C" fn (* mut crate :: fermented :: generics :: Vec_u8_32) } impl Fn_ARGS_std_os_raw_c_void_bool_Arr_u8_32_example_entry_point_wallet_WalletEx_RTRN_Vec_u8_32 { pub unsafe fn call (& self , o_0 : * const std :: os :: raw :: c_void , o_1 : bool , o_2 : [u8 ; 32] , o_3 : example_entry_point :: wallet :: WalletEx) -> Vec < [u8 ; 32] > { let ffi_result = (self . caller) (o_0 , o_1 , < crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionTo < [u8 ; 32] >> :: ffi_to (o_2) , ferment :: boxed (o_3)) ; let result = < crate :: fermented :: generics :: Vec_u8_32 as ferment :: FFIConversionFrom < Vec < [u8 ; 32] > >> :: ffi_from (ffi_result) ; (self . destructor) (ffi_result) ; result } } unsafe impl Send for Fn_ARGS_std_os_raw_c_void_bool_Arr_u8_32_example_entry_point_wallet_WalletEx_RTRN_Vec_u8_32 { } unsafe impl Sync for Fn_ARGS_std_os_raw_c_void_bool_Arr_u8_32_example_entry_point_wallet_WalletEx_RTRN_Vec_u8_32 { } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_std_os_raw_c_void_bool_Arr_u8_32_example_entry_point_wallet_WalletEx_RTRN_Vec_u8_32_ctor (caller : unsafe extern "C" fn (* const std :: os :: raw :: c_void , bool , * mut crate :: fermented :: generics :: Arr_u8_32 , * mut example_entry_point :: wallet :: WalletEx) -> * mut crate :: fermented :: generics :: Vec_u8_32 , destructor : unsafe extern "C" fn (* mut crate :: fermented :: generics :: Vec_u8_32)) -> * mut Fn_ARGS_std_os_raw_c_void_bool_Arr_u8_32_example_entry_point_wallet_WalletEx_RTRN_Vec_u8_32 { ferment :: boxed (Fn_ARGS_std_os_raw_c_void_bool_Arr_u8_32_example_entry_point_wallet_WalletEx_RTRN_Vec_u8_32 { caller , destructor }) } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_std_os_raw_c_void_bool_Arr_u8_32_example_entry_point_wallet_WalletEx_RTRN_Vec_u8_32_destroy (ffi : * mut Fn_ARGS_std_os_raw_c_void_bool_Arr_u8_32_example_entry_point_wallet_WalletEx_RTRN_Vec_u8_32) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Result_ok_bool_err_example_entry_point_keychain_KeyChainError { pub ok : * mut bool , pub error : * mut crate :: fermented :: types :: example_entry_point :: keychain :: example_entry_point_keychain_KeyChainError } impl ferment :: FFIConversionFrom < Result < bool , example_entry_point :: keychain :: KeyChainError > > for Result_ok_bool_err_example_entry_point_keychain_KeyChainError { unsafe fn ffi_from_const (ffi : * const Result_ok_bool_err_example_entry_point_keychain_KeyChainError) -> Result < bool , example_entry_point :: keychain :: KeyChainError > { let ffi_ref = & * ffi ; ferment :: fold_to_result (ffi_ref . ok , | o | * o , ffi_ref . error , | o | < crate :: fermented :: types :: example_entry_point :: keychain :: example_entry_point_keychain_KeyChainError as ferment :: FFIConversionFrom < example_entry_point :: keychain :: KeyChainError >> :: ffi_from (o)) } } impl ferment :: FFIConversionTo < Result < bool , example_entry_point :: keychain :: KeyChainError > > for Result_ok_bool_err_example_entry_point_keychain_KeyChainError { unsafe fn ffi_to_const (obj : Result < bool , example_entry_point :: keychain :: KeyChainError >) -> * const Result_ok_bool_err_example_entry_point_keychain_KeyChainError { ferment :: boxed ({ let (ok , error) = ferment :: to_result (obj , | o | ferment :: boxed (o) , | o | ferment :: FFIConversionTo :: ffi_to (o)) ; Self { ok , error } }) } } impl Drop for Result_ok_bool_err_example_entry_point_keychain_KeyChainError { fn drop (& mut self) { unsafe { ferment :: destroy_opt_primitive (self . ok) ; ferment :: unbox_any_opt (self . error) ; } } } # [no_mangle] pub unsafe extern "C" fn Result_ok_bool_err_example_entry_point_keychain_KeyChainError_ctor (ok : * mut bool , error : * mut crate :: fermented :: types :: example_entry_point :: keychain :: example_entry_point_keychain_KeyChainError) -> * mut Result_ok_bool_err_example_entry_point_keychain_KeyChainError { ferment :: boxed (Result_ok_bool_err_example_entry_point_keychain_KeyChainError { ok , error }) } # [no_mangle] pub unsafe extern "C" fn Result_ok_bool_err_example_entry_point_keychain_KeyChainError_destroy (ffi : * mut Result_ok_bool_err_example_entry_point_keychain_KeyChainError) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_bool_RTRN_Vec_u8 { pub obj : * mut crate :: fermented :: generics :: Fn_ARGS_std_os_raw_c_void_bool_RTRN_Vec_u8 } impl ferment :: FFIConversionFrom < std :: sync :: Arc < dyn Fn (* const std :: os :: raw :: c_void , bool) -> Vec < u8 > > > for std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_bool_RTRN_Vec_u8 { unsafe fn ffi_from_const (ffi : * const std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_bool_RTRN_Vec_u8) -> std :: sync :: Arc < dyn Fn (* const std :: os :: raw :: c_void , bool) -> Vec < u8 > > { let ffi_ref = & * ffi ; std :: sync :: Arc :: new (move | o_0 , o_1 | unsafe { (& * ffi_ref . obj) . call (o_0 , o_1) }) } } impl Drop for std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_bool_RTRN_Vec_u8 { fn drop (& mut self) { unsafe { ; } } } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_bool_RTRN_Vec_u8_ctor (obj : * mut crate :: fermented :: generics :: Fn_ARGS_std_os_raw_c_void_bool_RTRN_Vec_u8) -> * mut std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_bool_RTRN_Vec_u8 { ferment :: boxed (std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_bool_RTRN_Vec_u8 { obj }) } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_bool_RTRN_Vec_u8_destroy (ffi : * mut std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_bool_RTRN_Vec_u8) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Fn_ARGS_std_os_raw_c_void_example_entry_point_keychain_KeyChainKey_RTRN_Result_ok_bool_err_example_entry_point_keychain_KeyChainError { caller : unsafe extern "C" fn (* const std :: os :: raw :: c_void , * mut crate :: fermented :: types :: example_entry_point :: keychain :: example_entry_point_keychain_KeyChainKey) -> * mut crate :: fermented :: generics :: Result_ok_bool_err_example_entry_point_keychain_KeyChainError , destructor : unsafe extern "C" fn (* mut crate :: fermented :: generics :: Result_ok_bool_err_example_entry_point_keychain_KeyChainError) } impl Fn_ARGS_std_os_raw_c_void_example_entry_point_keychain_KeyChainKey_RTRN_Result_ok_bool_err_example_entry_point_keychain_KeyChainError { pub unsafe fn call (& self , o_0 : * const std :: os :: raw :: c_void , o_1 : example_entry_point :: keychain :: KeyChainKey) -> Result < bool , example_entry_point :: keychain :: KeyChainError > { let ffi_result = (self . caller) (o_0 , < crate :: fermented :: types :: example_entry_point :: keychain :: example_entry_point_keychain_KeyChainKey as ferment :: FFIConversionTo < example_entry_point :: keychain :: KeyChainKey >> :: ffi_to (o_1)) ; let result = < crate :: fermented :: generics :: Result_ok_bool_err_example_entry_point_keychain_KeyChainError as ferment :: FFIConversionFrom < Result < bool , example_entry_point :: keychain :: KeyChainError > >> :: ffi_from (ffi_result) ; (self . destructor) (ffi_result) ; result } } unsafe impl Send for Fn_ARGS_std_os_raw_c_void_example_entry_point_keychain_KeyChainKey_RTRN_Result_ok_bool_err_example_entry_point_keychain_KeyChainError { } unsafe impl Sync for Fn_ARGS_std_os_raw_c_void_example_entry_point_keychain_KeyChainKey_RTRN_Result_ok_bool_err_example_entry_point_keychain_KeyChainError { } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_std_os_raw_c_void_example_entry_point_keychain_KeyChainKey_RTRN_Result_ok_bool_err_example_entry_point_keychain_KeyChainError_ctor (caller : unsafe extern "C" fn (* const std :: os :: raw :: c_void , * mut crate :: fermented :: types :: example_entry_point :: keychain :: example_entry_point_keychain_KeyChainKey) -> * mut crate :: fermented :: generics :: Result_ok_bool_err_example_entry_point_keychain_KeyChainError , destructor : unsafe extern "C" fn (* mut crate :: fermented :: generics :: Result_ok_bool_err_example_entry_point_keychain_KeyChainError)) -> * mut Fn_ARGS_std_os_raw_c_void_example_entry_point_keychain_KeyChainKey_RTRN_Result_ok_bool_err_example_entry_point_keychain_KeyChainError { ferment :: boxed (Fn_ARGS_std_os_raw_c_void_example_entry_point_keychain_KeyChainKey_RTRN_Result_ok_bool_err_example_entry_point_keychain_KeyChainError { caller , destructor }) } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_std_os_raw_c_void_example_entry_point_keychain_KeyChainKey_RTRN_Result_ok_bool_err_example_entry_point_keychain_KeyChainError_destroy (ffi : * mut Fn_ARGS_std_os_raw_c_void_example_entry_point_keychain_KeyChainKey_RTRN_Result_ok_bool_err_example_entry_point_keychain_KeyChainError) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Fn_ARGS_u32_RTRN_Arr_u8_32 { caller : unsafe extern "C" fn (u32) -> * mut crate :: fermented :: generics :: Arr_u8_32 , destructor : unsafe extern "C" fn (* mut crate :: fermented :: generics :: Arr_u8_32) } impl Fn_ARGS_u32_RTRN_Arr_u8_32 { pub unsafe fn call (& self , o_0 : u32) -> [u8 ; 32] { let ffi_result = (self . caller) (o_0) ; let result = < crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionFrom < [u8 ; 32] >> :: ffi_from (ffi_result) ; (self . destructor) (ffi_result) ; result } } unsafe impl Send for Fn_ARGS_u32_RTRN_Arr_u8_32 { } unsafe impl Sync for Fn_ARGS_u32_RTRN_Arr_u8_32 { } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_u32_RTRN_Arr_u8_32_ctor (caller : unsafe extern "C" fn (u32) -> * mut crate :: fermented :: generics :: Arr_u8_32 , destructor : unsafe extern "C" fn (* mut crate :: fermented :: generics :: Arr_u8_32)) -> * mut Fn_ARGS_u32_RTRN_Arr_u8_32 { ferment :: boxed (Fn_ARGS_u32_RTRN_Arr_u8_32 { caller , destructor }) } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_u32_RTRN_Arr_u8_32_destroy (ffi : * mut Fn_ARGS_u32_RTRN_Arr_u8_32) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_Arr_u8_32_RTRN_bool { pub obj : * mut crate :: fermented :: generics :: Fn_ARGS_std_os_raw_c_void_Arr_u8_32_RTRN_bool } impl ferment :: FFIConversionFrom < std :: sync :: Arc < dyn Fn (* const std :: os :: raw :: c_void , [u8 ; 32]) -> bool > > for std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_Arr_u8_32_RTRN_bool { unsafe fn ffi_from_const (ffi : * const std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_Arr_u8_32_RTRN_bool) -> std :: sync :: Arc < dyn Fn (* const std :: os :: raw :: c_void , [u8 ; 32]) -> bool > { let ffi_ref = & * ffi ; std :: sync :: Arc :: new (move | o_0 , o_1 | unsafe { (& * ffi_ref . obj) . call (o_0 , o_1) }) } } impl Drop for std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_Arr_u8_32_RTRN_bool { fn drop (& mut self) { unsafe { ; } } } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_Arr_u8_32_RTRN_bool_ctor (obj : * mut crate :: fermented :: generics :: Fn_ARGS_std_os_raw_c_void_Arr_u8_32_RTRN_bool) -> * mut std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_Arr_u8_32_RTRN_bool { ferment :: boxed (std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_Arr_u8_32_RTRN_bool { obj }) } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_Arr_u8_32_RTRN_bool_destroy (ffi : * mut std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_Arr_u8_32_RTRN_bool) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_collections_HashSet_u8_32 { pub count : usize , pub values : * mut * mut crate :: fermented :: generics :: Arr_u8_32 } impl ferment :: FFIConversionFrom < std :: collections :: HashSet < [u8 ; 32] > > for std_collections_HashSet_u8_32 { unsafe fn ffi_from_const (ffi : * const std_collections_HashSet_u8_32) -> std :: collections :: HashSet < [u8 ; 32] > { let ffi_ref = & * ffi ; ferment :: from_complex_group (ffi_ref . values , ffi_ref . count) } } impl ferment :: FFIConversionTo < std :: collections :: HashSet < [u8 ; 32] > > for std_collections_HashSet_u8_32 { unsafe fn ffi_to_const (obj : std :: collections :: HashSet < [u8 ; 32] >) -> * const std_collections_HashSet_u8_32 { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_complex_group (obj . into_iter ()) }) } } impl Drop for std_collections_HashSet_u8_32 { fn drop (& mut self) { unsafe { ferment :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_HashSet_u8_32_ctor (count : usize , values : * mut * mut crate :: fermented :: generics :: Arr_u8_32) -> * mut std_collections_HashSet_u8_32 { ferment :: boxed (std_collections_HashSet_u8_32 { count , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_HashSet_u8_32_destroy (ffi : * mut std_collections_HashSet_u8_32) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Fn_ARGS_example_entry_point_entry_FFIContext_String_RTRN_Result_ok_Option_std_sync_Arc_example_entry_point_entry_SomeModel_err_String { caller : unsafe extern "C" fn (* const example_entry_point :: entry :: FFIContext , * mut std :: os :: raw :: c_char) -> * mut crate :: fermented :: generics :: Result_ok_Option_std_sync_Arc_example_entry_point_entry_SomeModel_err_String , destructor : unsafe extern "C" fn (* mut crate :: fermented :: generics :: Result_ok_Option_std_sync_Arc_example_entry_point_entry_SomeModel_err_String) } impl Fn_ARGS_example_entry_point_entry_FFIContext_String_RTRN_Result_ok_Option_std_sync_Arc_example_entry_point_entry_SomeModel_err_String { pub unsafe fn call (& self , o_0 : * const example_entry_point :: entry :: FFIContext , o_1 : String) -> Result < Option < std :: sync :: Arc < example_entry_point :: entry :: SomeModel > > , String > { let ffi_result = (self . caller) (o_0 , < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_1)) ; let result = < crate :: fermented :: generics :: Result_ok_Option_std_sync_Arc_example_entry_point_entry_SomeModel_err_String as ferment :: FFIConversionFrom < Result < Option < std :: sync :: Arc < example_entry_point :: entry :: SomeModel > > , String > >> :: ffi_from (ffi_result) ; (self . destructor) (ffi_result) ; result } } unsafe impl Send for Fn_ARGS_example_entry_point_entry_FFIContext_String_RTRN_Result_ok_Option_std_sync_Arc_example_entry_point_entry_SomeModel_err_String { } unsafe impl Sync for Fn_ARGS_example_entry_point_entry_FFIContext_String_RTRN_Result_ok_Option_std_sync_Arc_example_entry_point_entry_SomeModel_err_String { } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_example_entry_point_entry_FFIContext_String_RTRN_Result_ok_Option_std_sync_Arc_example_entry_point_entry_SomeModel_err_String_ctor (caller : unsafe extern "C" fn (* const example_entry_point :: entry :: FFIContext , * mut std :: os :: raw :: c_char) -> * mut crate :: fermented :: generics :: Result_ok_Option_std_sync_Arc_example_entry_point_entry_SomeModel_err_String , destructor : unsafe extern "C" fn (* mut crate :: fermented :: generics :: Result_ok_Option_std_sync_Arc_example_entry_point_entry_SomeModel_err_String)) -> * mut Fn_ARGS_example_entry_point_entry_FFIContext_String_RTRN_Result_ok_Option_std_sync_Arc_example_entry_point_entry_SomeModel_err_String { ferment :: boxed (Fn_ARGS_example_entry_point_entry_FFIContext_String_RTRN_Result_ok_Option_std_sync_Arc_example_entry_point_entry_SomeModel_err_String { caller , destructor }) } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_example_entry_point_entry_FFIContext_String_RTRN_Result_ok_Option_std_sync_Arc_example_entry_point_entry_SomeModel_err_String_destroy (ffi : * mut Fn_ARGS_example_entry_point_entry_FFIContext_String_RTRN_Result_ok_Option_std_sync_Arc_example_entry_point_entry_SomeModel_err_String) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Fn_ARGS_std_os_raw_c_void_bool_RTRN_Vec_u8 { caller : unsafe extern "C" fn (* const std :: os :: raw :: c_void , bool) -> * mut crate :: fermented :: generics :: Vec_u8 , destructor : unsafe extern "C" fn (* mut crate :: fermented :: generics :: Vec_u8) } impl Fn_ARGS_std_os_raw_c_void_bool_RTRN_Vec_u8 { pub unsafe fn call (& self , o_0 : * const std :: os :: raw :: c_void , o_1 : bool) -> Vec < u8 > { let ffi_result = (self . caller) (o_0 , o_1) ; let result = < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from (ffi_result) ; (self . destructor) (ffi_result) ; result } } unsafe impl Send for Fn_ARGS_std_os_raw_c_void_bool_RTRN_Vec_u8 { } unsafe impl Sync for Fn_ARGS_std_os_raw_c_void_bool_RTRN_Vec_u8 { } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_std_os_raw_c_void_bool_RTRN_Vec_u8_ctor (caller : unsafe extern "C" fn (* const std :: os :: raw :: c_void , bool) -> * mut crate :: fermented :: generics :: Vec_u8 , destructor : unsafe extern "C" fn (* mut crate :: fermented :: generics :: Vec_u8)) -> * mut Fn_ARGS_std_os_raw_c_void_bool_RTRN_Vec_u8 { ferment :: boxed (Fn_ARGS_std_os_raw_c_void_bool_RTRN_Vec_u8 { caller , destructor }) } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_std_os_raw_c_void_bool_RTRN_Vec_u8_destroy (ffi : * mut Fn_ARGS_std_os_raw_c_void_bool_RTRN_Vec_u8) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_sync_Arc_example_entry_point_entry_FFIContext { pub obj : * mut example_entry_point :: entry :: FFIContext } impl ferment :: FFIConversionFrom < std :: sync :: Arc < example_entry_point :: entry :: FFIContext > > for std_sync_Arc_example_entry_point_entry_FFIContext { unsafe fn ffi_from_const (ffi : * const std_sync_Arc_example_entry_point_entry_FFIContext) -> std :: sync :: Arc < example_entry_point :: entry :: FFIContext > { let ffi_ref = & * ffi ; std :: sync :: Arc :: from_raw (ffi_ref . obj) } } impl ferment :: FFIConversionTo < std :: sync :: Arc < example_entry_point :: entry :: FFIContext > > for std_sync_Arc_example_entry_point_entry_FFIContext { unsafe fn ffi_to_const (obj : std :: sync :: Arc < example_entry_point :: entry :: FFIContext >) -> * const std_sync_Arc_example_entry_point_entry_FFIContext { ferment :: boxed (Self { obj : std :: sync :: Arc :: into_raw (obj) . cast_mut () }) } } impl Drop for std_sync_Arc_example_entry_point_entry_FFIContext { fn drop (& mut self) { unsafe { ferment :: unbox_any (self . obj) ; } } } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_example_entry_point_entry_FFIContext_ctor (obj : * mut example_entry_point :: entry :: FFIContext) -> * mut std_sync_Arc_example_entry_point_entry_FFIContext { ferment :: boxed (std_sync_Arc_example_entry_point_entry_FFIContext { obj }) } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_example_entry_point_entry_FFIContext_destroy (ffi : * mut std_sync_Arc_example_entry_point_entry_FFIContext) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Result_ok_Option_std_sync_Arc_example_entry_point_entry_SomeModel_err_String { pub ok : * mut crate :: fermented :: generics :: std_sync_Arc_example_entry_point_entry_SomeModel , pub error : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < Result < Option < std :: sync :: Arc < example_entry_point :: entry :: SomeModel > > , String > > for Result_ok_Option_std_sync_Arc_example_entry_point_entry_SomeModel_err_String { unsafe fn ffi_from_const (ffi : * const Result_ok_Option_std_sync_Arc_example_entry_point_entry_SomeModel_err_String) -> Result < Option < std :: sync :: Arc < example_entry_point :: entry :: SomeModel > > , String > { let ffi_ref = & * ffi ; ferment :: fold_to_result (ffi_ref . ok , | o | < crate :: fermented :: generics :: std_sync_Arc_example_entry_point_entry_SomeModel as ferment :: FFIConversionFrom < std :: sync :: Arc < example_entry_point :: entry :: SomeModel > >> :: ffi_from_opt (o) , ffi_ref . error , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (o)) } } impl ferment :: FFIConversionTo < Result < Option < std :: sync :: Arc < example_entry_point :: entry :: SomeModel > > , String > > for Result_ok_Option_std_sync_Arc_example_entry_point_entry_SomeModel_err_String { unsafe fn ffi_to_const (obj : Result < Option < std :: sync :: Arc < example_entry_point :: entry :: SomeModel > > , String >) -> * const Result_ok_Option_std_sync_Arc_example_entry_point_entry_SomeModel_err_String { ferment :: boxed ({ let (ok , error) = ferment :: to_result (obj , | o | ferment :: FFIConversionTo :: ffi_to_opt (o) , | o | ferment :: FFIConversionTo :: ffi_to (o)) ; Self { ok , error } }) } } impl Drop for Result_ok_Option_std_sync_Arc_example_entry_point_entry_SomeModel_err_String { fn drop (& mut self) { unsafe { ferment :: unbox_any_opt (self . ok) ; ferment :: unbox_any_opt (self . error) ; } } } # [no_mangle] pub unsafe extern "C" fn Result_ok_Option_std_sync_Arc_example_entry_point_entry_SomeModel_err_String_ctor (ok : * mut crate :: fermented :: generics :: std_sync_Arc_example_entry_point_entry_SomeModel , error : * mut std :: os :: raw :: c_char) -> * mut Result_ok_Option_std_sync_Arc_example_entry_point_entry_SomeModel_err_String { ferment :: boxed (Result_ok_Option_std_sync_Arc_example_entry_point_entry_SomeModel_err_String { ok , error }) } # [no_mangle] pub unsafe extern "C" fn Result_ok_Option_std_sync_Arc_example_entry_point_entry_SomeModel_err_String_destroy (ffi : * mut Result_ok_Option_std_sync_Arc_example_entry_point_entry_SomeModel_err_String) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Fn_ARGS_std_os_raw_c_void_example_entry_point_keychain_KeyChainKey_RTRN_Result_ok_example_entry_point_keychain_KeyChainValue_err_example_entry_point_keychain_KeyChainError { caller : unsafe extern "C" fn (* const std :: os :: raw :: c_void , * mut crate :: fermented :: types :: example_entry_point :: keychain :: example_entry_point_keychain_KeyChainKey) -> * mut crate :: fermented :: generics :: Result_ok_example_entry_point_keychain_KeyChainValue_err_example_entry_point_keychain_KeyChainError , destructor : unsafe extern "C" fn (* mut crate :: fermented :: generics :: Result_ok_example_entry_point_keychain_KeyChainValue_err_example_entry_point_keychain_KeyChainError) } impl Fn_ARGS_std_os_raw_c_void_example_entry_point_keychain_KeyChainKey_RTRN_Result_ok_example_entry_point_keychain_KeyChainValue_err_example_entry_point_keychain_KeyChainError { pub unsafe fn call (& self , o_0 : * const std :: os :: raw :: c_void , o_1 : example_entry_point :: keychain :: KeyChainKey) -> Result < example_entry_point :: keychain :: KeyChainValue , example_entry_point :: keychain :: KeyChainError > { let ffi_result = (self . caller) (o_0 , < crate :: fermented :: types :: example_entry_point :: keychain :: example_entry_point_keychain_KeyChainKey as ferment :: FFIConversionTo < example_entry_point :: keychain :: KeyChainKey >> :: ffi_to (o_1)) ; let result = < crate :: fermented :: generics :: Result_ok_example_entry_point_keychain_KeyChainValue_err_example_entry_point_keychain_KeyChainError as ferment :: FFIConversionFrom < Result < example_entry_point :: keychain :: KeyChainValue , example_entry_point :: keychain :: KeyChainError > >> :: ffi_from (ffi_result) ; (self . destructor) (ffi_result) ; result } } unsafe impl Send for Fn_ARGS_std_os_raw_c_void_example_entry_point_keychain_KeyChainKey_RTRN_Result_ok_example_entry_point_keychain_KeyChainValue_err_example_entry_point_keychain_KeyChainError { } unsafe impl Sync for Fn_ARGS_std_os_raw_c_void_example_entry_point_keychain_KeyChainKey_RTRN_Result_ok_example_entry_point_keychain_KeyChainValue_err_example_entry_point_keychain_KeyChainError { } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_std_os_raw_c_void_example_entry_point_keychain_KeyChainKey_RTRN_Result_ok_example_entry_point_keychain_KeyChainValue_err_example_entry_point_keychain_KeyChainError_ctor (caller : unsafe extern "C" fn (* const std :: os :: raw :: c_void , * mut crate :: fermented :: types :: example_entry_point :: keychain :: example_entry_point_keychain_KeyChainKey) -> * mut crate :: fermented :: generics :: Result_ok_example_entry_point_keychain_KeyChainValue_err_example_entry_point_keychain_KeyChainError , destructor : unsafe extern "C" fn (* mut crate :: fermented :: generics :: Result_ok_example_entry_point_keychain_KeyChainValue_err_example_entry_point_keychain_KeyChainError)) -> * mut Fn_ARGS_std_os_raw_c_void_example_entry_point_keychain_KeyChainKey_RTRN_Result_ok_example_entry_point_keychain_KeyChainValue_err_example_entry_point_keychain_KeyChainError { ferment :: boxed (Fn_ARGS_std_os_raw_c_void_example_entry_point_keychain_KeyChainKey_RTRN_Result_ok_example_entry_point_keychain_KeyChainValue_err_example_entry_point_keychain_KeyChainError { caller , destructor }) } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_std_os_raw_c_void_example_entry_point_keychain_KeyChainKey_RTRN_Result_ok_example_entry_point_keychain_KeyChainValue_err_example_entry_point_keychain_KeyChainError_destroy (ffi : * mut Fn_ARGS_std_os_raw_c_void_example_entry_point_keychain_KeyChainKey_RTRN_Result_ok_example_entry_point_keychain_KeyChainValue_err_example_entry_point_keychain_KeyChainError) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Fn_ARGS_std_os_raw_c_void_bool_bool_bool_i32_RTRN_Vec_u8_32 { caller : unsafe extern "C" fn (* const std :: os :: raw :: c_void , bool , bool , bool , i32) -> * mut crate :: fermented :: generics :: Vec_u8_32 , destructor : unsafe extern "C" fn (* mut crate :: fermented :: generics :: Vec_u8_32) } impl Fn_ARGS_std_os_raw_c_void_bool_bool_bool_i32_RTRN_Vec_u8_32 { pub unsafe fn call (& self , o_0 : * const std :: os :: raw :: c_void , o_1 : bool , o_2 : bool , o_3 : bool , o_4 : i32) -> Vec < [u8 ; 32] > { let ffi_result = (self . caller) (o_0 , o_1 , o_2 , o_3 , o_4) ; let result = < crate :: fermented :: generics :: Vec_u8_32 as ferment :: FFIConversionFrom < Vec < [u8 ; 32] > >> :: ffi_from (ffi_result) ; (self . destructor) (ffi_result) ; result } } unsafe impl Send for Fn_ARGS_std_os_raw_c_void_bool_bool_bool_i32_RTRN_Vec_u8_32 { } unsafe impl Sync for Fn_ARGS_std_os_raw_c_void_bool_bool_bool_i32_RTRN_Vec_u8_32 { } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_std_os_raw_c_void_bool_bool_bool_i32_RTRN_Vec_u8_32_ctor (caller : unsafe extern "C" fn (* const std :: os :: raw :: c_void , bool , bool , bool , i32) -> * mut crate :: fermented :: generics :: Vec_u8_32 , destructor : unsafe extern "C" fn (* mut crate :: fermented :: generics :: Vec_u8_32)) -> * mut Fn_ARGS_std_os_raw_c_void_bool_bool_bool_i32_RTRN_Vec_u8_32 { ferment :: boxed (Fn_ARGS_std_os_raw_c_void_bool_bool_bool_i32_RTRN_Vec_u8_32 { caller , destructor }) } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_std_os_raw_c_void_bool_bool_bool_i32_RTRN_Vec_u8_32_destroy (ffi : * mut Fn_ARGS_std_os_raw_c_void_bool_bool_bool_i32_RTRN_Vec_u8_32) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_sync_Arc_example_entry_point_entry_SomeModel { pub obj : * mut crate :: fermented :: types :: example_entry_point :: entry :: example_entry_point_entry_SomeModel } impl ferment :: FFIConversionFrom < std :: sync :: Arc < example_entry_point :: entry :: SomeModel > > for std_sync_Arc_example_entry_point_entry_SomeModel { unsafe fn ffi_from_const (ffi : * const std_sync_Arc_example_entry_point_entry_SomeModel) -> std :: sync :: Arc < example_entry_point :: entry :: SomeModel > { let ffi_ref = & * ffi ; std :: sync :: Arc :: new (ferment :: FFIConversionFrom :: ffi_from (ffi_ref . obj)) } } impl ferment :: FFIConversionTo < std :: sync :: Arc < example_entry_point :: entry :: SomeModel > > for std_sync_Arc_example_entry_point_entry_SomeModel { unsafe fn ffi_to_const (obj : std :: sync :: Arc < example_entry_point :: entry :: SomeModel >) -> * const std_sync_Arc_example_entry_point_entry_SomeModel { ferment :: boxed (Self { obj : ferment :: FFIConversionTo :: ffi_to ((* obj) . clone ()) }) } } impl Drop for std_sync_Arc_example_entry_point_entry_SomeModel { fn drop (& mut self) { unsafe { ferment :: unbox_any (self . obj) ; } } } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_example_entry_point_entry_SomeModel_ctor (obj : * mut crate :: fermented :: types :: example_entry_point :: entry :: example_entry_point_entry_SomeModel) -> * mut std_sync_Arc_example_entry_point_entry_SomeModel { ferment :: boxed (std_sync_Arc_example_entry_point_entry_SomeModel { obj }) } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_example_entry_point_entry_SomeModel_destroy (ffi : * mut std_sync_Arc_example_entry_point_entry_SomeModel) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_collections_Map_keys_u8_arr_32_values_Vec_u8 { pub count : usize , pub keys : * mut * mut crate :: fermented :: generics :: Arr_u8_32 , pub values : * mut * mut crate :: fermented :: generics :: Vec_u8 } impl ferment :: FFIConversionFrom < std :: collections :: HashMap < [u8 ; 32] , Vec < u8 > > > for std_collections_Map_keys_u8_arr_32_values_Vec_u8 { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_u8_arr_32_values_Vec_u8) -> std :: collections :: HashMap < [u8 ; 32] , Vec < u8 > > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | < crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionFrom < [u8 ; 32] >> :: ffi_from (o) , | o | < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from (o)) } } impl ferment :: FFIConversionTo < std :: collections :: HashMap < [u8 ; 32] , Vec < u8 > > > for std_collections_Map_keys_u8_arr_32_values_Vec_u8 { unsafe fn ffi_to_const (obj : std :: collections :: HashMap < [u8 ; 32] , Vec < u8 > >) -> * const std_collections_Map_keys_u8_arr_32_values_Vec_u8 { ferment :: boxed (Self { count : obj . len () , keys : ferment :: to_complex_group (obj . keys () . cloned ()) , values : ferment :: to_complex_group (obj . values () . cloned ()) }) } } impl Drop for std_collections_Map_keys_u8_arr_32_values_Vec_u8 { fn drop (& mut self) { unsafe { ferment :: unbox_any_vec_ptr (self . keys , self . count) ; ferment :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_u8_arr_32_values_Vec_u8_ctor (count : usize , keys : * mut * mut crate :: fermented :: generics :: Arr_u8_32 , values : * mut * mut crate :: fermented :: generics :: Vec_u8) -> * mut std_collections_Map_keys_u8_arr_32_values_Vec_u8 { ferment :: boxed (std_collections_Map_keys_u8_arr_32_values_Vec_u8 { count , keys , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_u8_arr_32_values_Vec_u8_destroy (ffi : * mut std_collections_Map_keys_u8_arr_32_values_Vec_u8) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_Arr_u8_32_Arr_u8_32_RTRN_bool { pub obj : * mut crate :: fermented :: generics :: Fn_ARGS_std_os_raw_c_void_Arr_u8_32_Arr_u8_32_RTRN_bool } impl ferment :: FFIConversionFrom < std :: sync :: Arc < dyn Fn (* const std :: os :: raw :: c_void , [u8 ; 32] , [u8 ; 32]) -> bool > > for std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_Arr_u8_32_Arr_u8_32_RTRN_bool { unsafe fn ffi_from_const (ffi : * const std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_Arr_u8_32_Arr_u8_32_RTRN_bool) -> std :: sync :: Arc < dyn Fn (* const std :: os :: raw :: c_void , [u8 ; 32] , [u8 ; 32]) -> bool > { let ffi_ref = & * ffi ; std :: sync :: Arc :: new (move | o_0 , o_1 , o_2 | unsafe { (& * ffi_ref . obj) . call (o_0 , o_1 , o_2) }) } } impl Drop for std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_Arr_u8_32_Arr_u8_32_RTRN_bool { fn drop (& mut self) { unsafe { ; } } } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_Arr_u8_32_Arr_u8_32_RTRN_bool_ctor (obj : * mut crate :: fermented :: generics :: Fn_ARGS_std_os_raw_c_void_Arr_u8_32_Arr_u8_32_RTRN_bool) -> * mut std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_Arr_u8_32_Arr_u8_32_RTRN_bool { ferment :: boxed (std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_Arr_u8_32_Arr_u8_32_RTRN_bool { obj }) } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_Arr_u8_32_Arr_u8_32_RTRN_bool_destroy (ffi : * mut std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_Arr_u8_32_Arr_u8_32_RTRN_bool) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Arr_u8_48 { pub count : usize , pub values : * mut u8 } impl ferment :: FFIConversionFrom < [u8 ; 48] > for Arr_u8_48 { unsafe fn ffi_from_const (ffi : * const Arr_u8_48) -> [u8 ; 48] { let ffi_ref = & * ffi ; let vec : Vec < u8 > = ferment :: from_primitive_group (ffi_ref . values , ffi_ref . count) ; vec . try_into () . unwrap () } } impl ferment :: FFIConversionTo < [u8 ; 48] > for Arr_u8_48 { unsafe fn ffi_to_const (obj : [u8 ; 48]) -> * const Arr_u8_48 { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_primitive_group (obj . into_iter ()) }) } } impl Drop for Arr_u8_48 { fn drop (& mut self) { unsafe { ferment :: unbox_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn Arr_u8_48_ctor (count : usize , values : * mut u8) -> * mut Arr_u8_48 { ferment :: boxed (Arr_u8_48 { count , values }) } # [no_mangle] pub unsafe extern "C" fn Arr_u8_48_destroy (ffi : * mut Arr_u8_48) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Arr_u8_32 { pub count : usize , pub values : * mut u8 } impl ferment :: FFIConversionFrom < [u8 ; 32] > for Arr_u8_32 { unsafe fn ffi_from_const (ffi : * const Arr_u8_32) -> [u8 ; 32] { let ffi_ref = & * ffi ; let vec : Vec < u8 > = ferment :: from_primitive_group (ffi_ref . values , ffi_ref . count) ; vec . try_into () . unwrap () } } impl ferment :: FFIConversionTo < [u8 ; 32] > for Arr_u8_32 { unsafe fn ffi_to_const (obj : [u8 ; 32]) -> * const Arr_u8_32 { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_primitive_group (obj . into_iter ()) }) } } impl Drop for Arr_u8_32 { fn drop (& mut self) { unsafe { ferment :: unbox_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn Arr_u8_32_ctor (count : usize , values : * mut u8) -> * mut Arr_u8_32 { ferment :: boxed (Arr_u8_32 { count , values }) } # [no_mangle] pub unsafe extern "C" fn Arr_u8_32_destroy (ffi : * mut Arr_u8_32) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Vec_Vec_u8 { pub count : usize , pub values : * mut * mut crate :: fermented :: generics :: Vec_u8 } impl ferment :: FFIConversionFrom < Vec < Vec < u8 > > > for Vec_Vec_u8 { unsafe fn ffi_from_const (ffi : * const Vec_Vec_u8) -> Vec < Vec < u8 > > { let ffi_ref = & * ffi ; ferment :: from_complex_group (ffi_ref . values , ffi_ref . count) } } impl ferment :: FFIConversionTo < Vec < Vec < u8 > > > for Vec_Vec_u8 { unsafe fn ffi_to_const (obj : Vec < Vec < u8 > >) -> * const Vec_Vec_u8 { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_complex_group (obj . into_iter ()) }) } } impl Drop for Vec_Vec_u8 { fn drop (& mut self) { unsafe { ferment :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn Vec_Vec_u8_ctor (count : usize , values : * mut * mut crate :: fermented :: generics :: Vec_u8) -> * mut Vec_Vec_u8 { ferment :: boxed (Vec_Vec_u8 { count , values }) } # [no_mangle] pub unsafe extern "C" fn Vec_Vec_u8_destroy (ffi : * mut Vec_Vec_u8) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Fn_ARGS_std_os_raw_c_void_Vec_u8_32_Arr_u8_32_bool_Arr_u8_32_RTRN_bool { caller : unsafe extern "C" fn (* const std :: os :: raw :: c_void , * mut crate :: fermented :: generics :: Vec_u8_32 , * mut crate :: fermented :: generics :: Arr_u8_32 , bool , * mut crate :: fermented :: generics :: Arr_u8_32) -> bool , destructor : unsafe extern "C" fn (bool) } impl Fn_ARGS_std_os_raw_c_void_Vec_u8_32_Arr_u8_32_bool_Arr_u8_32_RTRN_bool { pub unsafe fn call (& self , o_0 : * const std :: os :: raw :: c_void , o_1 : Vec < [u8 ; 32] > , o_2 : [u8 ; 32] , o_3 : bool , o_4 : [u8 ; 32]) -> bool { let ffi_result = (self . caller) (o_0 , < crate :: fermented :: generics :: Vec_u8_32 as ferment :: FFIConversionTo < Vec < [u8 ; 32] > >> :: ffi_to (o_1) , < crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionTo < [u8 ; 32] >> :: ffi_to (o_2) , o_3 , < crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionTo < [u8 ; 32] >> :: ffi_to (o_4)) ; ffi_result } } unsafe impl Send for Fn_ARGS_std_os_raw_c_void_Vec_u8_32_Arr_u8_32_bool_Arr_u8_32_RTRN_bool { } unsafe impl Sync for Fn_ARGS_std_os_raw_c_void_Vec_u8_32_Arr_u8_32_bool_Arr_u8_32_RTRN_bool { } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_std_os_raw_c_void_Vec_u8_32_Arr_u8_32_bool_Arr_u8_32_RTRN_bool_ctor (caller : unsafe extern "C" fn (* const std :: os :: raw :: c_void , * mut crate :: fermented :: generics :: Vec_u8_32 , * mut crate :: fermented :: generics :: Arr_u8_32 , bool , * mut crate :: fermented :: generics :: Arr_u8_32) -> bool , destructor : unsafe extern "C" fn (bool)) -> * mut Fn_ARGS_std_os_raw_c_void_Vec_u8_32_Arr_u8_32_bool_Arr_u8_32_RTRN_bool { ferment :: boxed (Fn_ARGS_std_os_raw_c_void_Vec_u8_32_Arr_u8_32_bool_Arr_u8_32_RTRN_bool { caller , destructor }) } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_std_os_raw_c_void_Vec_u8_32_Arr_u8_32_bool_Arr_u8_32_RTRN_bool_destroy (ffi : * mut Fn_ARGS_std_os_raw_c_void_Vec_u8_32_Arr_u8_32_bool_Arr_u8_32_RTRN_bool) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Fn_ARGS_u32_RTRN_example_entry_point_entry_SomeModel { caller : unsafe extern "C" fn (u32) -> * mut crate :: fermented :: types :: example_entry_point :: entry :: example_entry_point_entry_SomeModel , destructor : unsafe extern "C" fn (* mut crate :: fermented :: types :: example_entry_point :: entry :: example_entry_point_entry_SomeModel) } impl Fn_ARGS_u32_RTRN_example_entry_point_entry_SomeModel { pub unsafe fn call (& self , o_0 : u32) -> example_entry_point :: entry :: SomeModel { let ffi_result = (self . caller) (o_0) ; let result = < crate :: fermented :: types :: example_entry_point :: entry :: example_entry_point_entry_SomeModel as ferment :: FFIConversionFrom < example_entry_point :: entry :: SomeModel >> :: ffi_from (ffi_result) ; (self . destructor) (ffi_result) ; result } } unsafe impl Send for Fn_ARGS_u32_RTRN_example_entry_point_entry_SomeModel { } unsafe impl Sync for Fn_ARGS_u32_RTRN_example_entry_point_entry_SomeModel { } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_u32_RTRN_example_entry_point_entry_SomeModel_ctor (caller : unsafe extern "C" fn (u32) -> * mut crate :: fermented :: types :: example_entry_point :: entry :: example_entry_point_entry_SomeModel , destructor : unsafe extern "C" fn (* mut crate :: fermented :: types :: example_entry_point :: entry :: example_entry_point_entry_SomeModel)) -> * mut Fn_ARGS_u32_RTRN_example_entry_point_entry_SomeModel { ferment :: boxed (Fn_ARGS_u32_RTRN_example_entry_point_entry_SomeModel { caller , destructor }) } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_u32_RTRN_example_entry_point_entry_SomeModel_destroy (ffi : * mut Fn_ARGS_u32_RTRN_example_entry_point_entry_SomeModel) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Fn_ARGS_std_os_raw_c_void_Arr_u8_32_Arr_u8_32_RTRN_bool { caller : unsafe extern "C" fn (* const std :: os :: raw :: c_void , * mut crate :: fermented :: generics :: Arr_u8_32 , * mut crate :: fermented :: generics :: Arr_u8_32) -> bool , destructor : unsafe extern "C" fn (bool) } impl Fn_ARGS_std_os_raw_c_void_Arr_u8_32_Arr_u8_32_RTRN_bool { pub unsafe fn call (& self , o_0 : * const std :: os :: raw :: c_void , o_1 : [u8 ; 32] , o_2 : [u8 ; 32]) -> bool { let ffi_result = (self . caller) (o_0 , < crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionTo < [u8 ; 32] >> :: ffi_to (o_1) , < crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionTo < [u8 ; 32] >> :: ffi_to (o_2)) ; ffi_result } } unsafe impl Send for Fn_ARGS_std_os_raw_c_void_Arr_u8_32_Arr_u8_32_RTRN_bool { } unsafe impl Sync for Fn_ARGS_std_os_raw_c_void_Arr_u8_32_Arr_u8_32_RTRN_bool { } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_std_os_raw_c_void_Arr_u8_32_Arr_u8_32_RTRN_bool_ctor (caller : unsafe extern "C" fn (* const std :: os :: raw :: c_void , * mut crate :: fermented :: generics :: Arr_u8_32 , * mut crate :: fermented :: generics :: Arr_u8_32) -> bool , destructor : unsafe extern "C" fn (bool)) -> * mut Fn_ARGS_std_os_raw_c_void_Arr_u8_32_Arr_u8_32_RTRN_bool { ferment :: boxed (Fn_ARGS_std_os_raw_c_void_Arr_u8_32_Arr_u8_32_RTRN_bool { caller , destructor }) } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_std_os_raw_c_void_Arr_u8_32_Arr_u8_32_RTRN_bool_destroy (ffi : * mut Fn_ARGS_std_os_raw_c_void_Arr_u8_32_Arr_u8_32_RTRN_bool) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_Arr_u8_32_RTRN_Option_u8_32 { pub obj : * mut crate :: fermented :: generics :: Fn_ARGS_std_os_raw_c_void_Arr_u8_32_RTRN_Option_u8_32 } impl ferment :: FFIConversionFrom < std :: sync :: Arc < dyn Fn (* const std :: os :: raw :: c_void , [u8 ; 32]) -> Option < [u8 ; 32] > > > for std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_Arr_u8_32_RTRN_Option_u8_32 { unsafe fn ffi_from_const (ffi : * const std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_Arr_u8_32_RTRN_Option_u8_32) -> std :: sync :: Arc < dyn Fn (* const std :: os :: raw :: c_void , [u8 ; 32]) -> Option < [u8 ; 32] > > { let ffi_ref = & * ffi ; std :: sync :: Arc :: new (move | o_0 , o_1 | unsafe { (& * ffi_ref . obj) . call (o_0 , o_1) }) } } impl Drop for std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_Arr_u8_32_RTRN_Option_u8_32 { fn drop (& mut self) { unsafe { ; } } } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_Arr_u8_32_RTRN_Option_u8_32_ctor (obj : * mut crate :: fermented :: generics :: Fn_ARGS_std_os_raw_c_void_Arr_u8_32_RTRN_Option_u8_32) -> * mut std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_Arr_u8_32_RTRN_Option_u8_32 { ferment :: boxed (std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_Arr_u8_32_RTRN_Option_u8_32 { obj }) } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_Arr_u8_32_RTRN_Option_u8_32_destroy (ffi : * mut std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_Arr_u8_32_RTRN_Option_u8_32) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Fn_ARGS_std_os_raw_c_void_RTRN_bool { caller : unsafe extern "C" fn (* const std :: os :: raw :: c_void) -> bool , destructor : unsafe extern "C" fn (bool) } impl Fn_ARGS_std_os_raw_c_void_RTRN_bool { pub unsafe fn call (& self , o_0 : * const std :: os :: raw :: c_void) -> bool { let ffi_result = (self . caller) (o_0) ; ffi_result } } unsafe impl Send for Fn_ARGS_std_os_raw_c_void_RTRN_bool { } unsafe impl Sync for Fn_ARGS_std_os_raw_c_void_RTRN_bool { } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_std_os_raw_c_void_RTRN_bool_ctor (caller : unsafe extern "C" fn (* const std :: os :: raw :: c_void) -> bool , destructor : unsafe extern "C" fn (bool)) -> * mut Fn_ARGS_std_os_raw_c_void_RTRN_bool { ferment :: boxed (Fn_ARGS_std_os_raw_c_void_RTRN_bool { caller , destructor }) } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_std_os_raw_c_void_RTRN_bool_destroy (ffi : * mut Fn_ARGS_std_os_raw_c_void_RTRN_bool) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_Arr_u8_32_bool_RTRN_Option_u8_32 { pub obj : * mut crate :: fermented :: generics :: Fn_ARGS_std_os_raw_c_void_Arr_u8_32_bool_RTRN_Option_u8_32 } impl ferment :: FFIConversionFrom < std :: sync :: Arc < dyn Fn (* const std :: os :: raw :: c_void , [u8 ; 32] , bool) -> Option < [u8 ; 32] > > > for std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_Arr_u8_32_bool_RTRN_Option_u8_32 { unsafe fn ffi_from_const (ffi : * const std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_Arr_u8_32_bool_RTRN_Option_u8_32) -> std :: sync :: Arc < dyn Fn (* const std :: os :: raw :: c_void , [u8 ; 32] , bool) -> Option < [u8 ; 32] > > { let ffi_ref = & * ffi ; std :: sync :: Arc :: new (move | o_0 , o_1 , o_2 | unsafe { (& * ffi_ref . obj) . call (o_0 , o_1 , o_2) }) } } impl Drop for std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_Arr_u8_32_bool_RTRN_Option_u8_32 { fn drop (& mut self) { unsafe { ; } } } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_Arr_u8_32_bool_RTRN_Option_u8_32_ctor (obj : * mut crate :: fermented :: generics :: Fn_ARGS_std_os_raw_c_void_Arr_u8_32_bool_RTRN_Option_u8_32) -> * mut std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_Arr_u8_32_bool_RTRN_Option_u8_32 { ferment :: boxed (std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_Arr_u8_32_bool_RTRN_Option_u8_32 { obj }) } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_Arr_u8_32_bool_RTRN_Option_u8_32_destroy (ffi : * mut std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_Arr_u8_32_bool_RTRN_Option_u8_32) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Vec_u8 { pub count : usize , pub values : * mut u8 } impl ferment :: FFIConversionFrom < Vec < u8 > > for Vec_u8 { unsafe fn ffi_from_const (ffi : * const Vec_u8) -> Vec < u8 > { let ffi_ref = & * ffi ; ferment :: from_primitive_group (ffi_ref . values , ffi_ref . count) } } impl ferment :: FFIConversionTo < Vec < u8 > > for Vec_u8 { unsafe fn ffi_to_const (obj : Vec < u8 >) -> * const Vec_u8 { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_primitive_group (obj . into_iter ()) }) } } impl Drop for Vec_u8 { fn drop (& mut self) { unsafe { ferment :: unbox_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn Vec_u8_ctor (count : usize , values : * mut u8) -> * mut Vec_u8 { ferment :: boxed (Vec_u8 { count , values }) } # [no_mangle] pub unsafe extern "C" fn Vec_u8_destroy (ffi : * mut Vec_u8) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Fn_ARGS_std_os_raw_c_void_Arr_u8_32_RTRN_Option_u8_32 { caller : unsafe extern "C" fn (* const std :: os :: raw :: c_void , * mut crate :: fermented :: generics :: Arr_u8_32) -> * mut crate :: fermented :: generics :: Arr_u8_32 , destructor : unsafe extern "C" fn (* mut crate :: fermented :: generics :: Arr_u8_32) } impl Fn_ARGS_std_os_raw_c_void_Arr_u8_32_RTRN_Option_u8_32 { pub unsafe fn call (& self , o_0 : * const std :: os :: raw :: c_void , o_1 : [u8 ; 32]) -> Option < [u8 ; 32] > { let ffi_result = (self . caller) (o_0 , < crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionTo < [u8 ; 32] >> :: ffi_to (o_1)) ; let result = < crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionFrom < [u8 ; 32] >> :: ffi_from_opt (ffi_result) ; (self . destructor) (ffi_result) ; result } } unsafe impl Send for Fn_ARGS_std_os_raw_c_void_Arr_u8_32_RTRN_Option_u8_32 { } unsafe impl Sync for Fn_ARGS_std_os_raw_c_void_Arr_u8_32_RTRN_Option_u8_32 { } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_std_os_raw_c_void_Arr_u8_32_RTRN_Option_u8_32_ctor (caller : unsafe extern "C" fn (* const std :: os :: raw :: c_void , * mut crate :: fermented :: generics :: Arr_u8_32) -> * mut crate :: fermented :: generics :: Arr_u8_32 , destructor : unsafe extern "C" fn (* mut crate :: fermented :: generics :: Arr_u8_32)) -> * mut Fn_ARGS_std_os_raw_c_void_Arr_u8_32_RTRN_Option_u8_32 { ferment :: boxed (Fn_ARGS_std_os_raw_c_void_Arr_u8_32_RTRN_Option_u8_32 { caller , destructor }) } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_std_os_raw_c_void_Arr_u8_32_RTRN_Option_u8_32_destroy (ffi : * mut Fn_ARGS_std_os_raw_c_void_Arr_u8_32_RTRN_Option_u8_32) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_String_RTRN_bool { pub obj : * mut crate :: fermented :: generics :: Fn_ARGS_std_os_raw_c_void_String_RTRN_bool } impl ferment :: FFIConversionFrom < std :: sync :: Arc < dyn Fn (* const std :: os :: raw :: c_void , String) -> bool > > for std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_String_RTRN_bool { unsafe fn ffi_from_const (ffi : * const std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_String_RTRN_bool) -> std :: sync :: Arc < dyn Fn (* const std :: os :: raw :: c_void , String) -> bool > { let ffi_ref = & * ffi ; std :: sync :: Arc :: new (move | o_0 , o_1 | unsafe { (& * ffi_ref . obj) . call (o_0 , o_1) }) } } impl Drop for std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_String_RTRN_bool { fn drop (& mut self) { unsafe { ; } } } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_String_RTRN_bool_ctor (obj : * mut crate :: fermented :: generics :: Fn_ARGS_std_os_raw_c_void_String_RTRN_bool) -> * mut std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_String_RTRN_bool { ferment :: boxed (std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_String_RTRN_bool { obj }) } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_String_RTRN_bool_destroy (ffi : * mut std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_String_RTRN_bool) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Result_ok_example_entry_point_keychain_KeyChainValue_err_example_entry_point_keychain_KeyChainError { pub ok : * mut crate :: fermented :: types :: example_entry_point :: keychain :: example_entry_point_keychain_KeyChainValue , pub error : * mut crate :: fermented :: types :: example_entry_point :: keychain :: example_entry_point_keychain_KeyChainError } impl ferment :: FFIConversionFrom < Result < example_entry_point :: keychain :: KeyChainValue , example_entry_point :: keychain :: KeyChainError > > for Result_ok_example_entry_point_keychain_KeyChainValue_err_example_entry_point_keychain_KeyChainError { unsafe fn ffi_from_const (ffi : * const Result_ok_example_entry_point_keychain_KeyChainValue_err_example_entry_point_keychain_KeyChainError) -> Result < example_entry_point :: keychain :: KeyChainValue , example_entry_point :: keychain :: KeyChainError > { let ffi_ref = & * ffi ; ferment :: fold_to_result (ffi_ref . ok , | o | < crate :: fermented :: types :: example_entry_point :: keychain :: example_entry_point_keychain_KeyChainValue as ferment :: FFIConversionFrom < example_entry_point :: keychain :: KeyChainValue >> :: ffi_from (o) , ffi_ref . error , | o | < crate :: fermented :: types :: example_entry_point :: keychain :: example_entry_point_keychain_KeyChainError as ferment :: FFIConversionFrom < example_entry_point :: keychain :: KeyChainError >> :: ffi_from (o)) } } impl ferment :: FFIConversionTo < Result < example_entry_point :: keychain :: KeyChainValue , example_entry_point :: keychain :: KeyChainError > > for Result_ok_example_entry_point_keychain_KeyChainValue_err_example_entry_point_keychain_KeyChainError { unsafe fn ffi_to_const (obj : Result < example_entry_point :: keychain :: KeyChainValue , example_entry_point :: keychain :: KeyChainError >) -> * const Result_ok_example_entry_point_keychain_KeyChainValue_err_example_entry_point_keychain_KeyChainError { ferment :: boxed ({ let (ok , error) = ferment :: to_result (obj , | o | ferment :: FFIConversionTo :: ffi_to (o) , | o | ferment :: FFIConversionTo :: ffi_to (o)) ; Self { ok , error } }) } } impl Drop for Result_ok_example_entry_point_keychain_KeyChainValue_err_example_entry_point_keychain_KeyChainError { fn drop (& mut self) { unsafe { ferment :: unbox_any_opt (self . ok) ; ferment :: unbox_any_opt (self . error) ; } } } # [no_mangle] pub unsafe extern "C" fn Result_ok_example_entry_point_keychain_KeyChainValue_err_example_entry_point_keychain_KeyChainError_ctor (ok : * mut crate :: fermented :: types :: example_entry_point :: keychain :: example_entry_point_keychain_KeyChainValue , error : * mut crate :: fermented :: types :: example_entry_point :: keychain :: example_entry_point_keychain_KeyChainError) -> * mut Result_ok_example_entry_point_keychain_KeyChainValue_err_example_entry_point_keychain_KeyChainError { ferment :: boxed (Result_ok_example_entry_point_keychain_KeyChainValue_err_example_entry_point_keychain_KeyChainError { ok , error }) } # [no_mangle] pub unsafe extern "C" fn Result_ok_example_entry_point_keychain_KeyChainValue_err_example_entry_point_keychain_KeyChainError_destroy (ffi : * mut Result_ok_example_entry_point_keychain_KeyChainValue_err_example_entry_point_keychain_KeyChainError) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_Vec_u8_32_Arr_u8_32_bool_Arr_u8_32_RTRN_bool { pub obj : * mut crate :: fermented :: generics :: Fn_ARGS_std_os_raw_c_void_Vec_u8_32_Arr_u8_32_bool_Arr_u8_32_RTRN_bool } impl ferment :: FFIConversionFrom < std :: sync :: Arc < dyn Fn (* const std :: os :: raw :: c_void , Vec < [u8 ; 32] > , [u8 ; 32] , bool , [u8 ; 32]) -> bool > > for std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_Vec_u8_32_Arr_u8_32_bool_Arr_u8_32_RTRN_bool { unsafe fn ffi_from_const (ffi : * const std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_Vec_u8_32_Arr_u8_32_bool_Arr_u8_32_RTRN_bool) -> std :: sync :: Arc < dyn Fn (* const std :: os :: raw :: c_void , Vec < [u8 ; 32] > , [u8 ; 32] , bool , [u8 ; 32]) -> bool > { let ffi_ref = & * ffi ; std :: sync :: Arc :: new (move | o_0 , o_1 , o_2 , o_3 , o_4 | unsafe { (& * ffi_ref . obj) . call (o_0 , o_1 , o_2 , o_3 , o_4) }) } } impl Drop for std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_Vec_u8_32_Arr_u8_32_bool_Arr_u8_32_RTRN_bool { fn drop (& mut self) { unsafe { ; } } } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_Vec_u8_32_Arr_u8_32_bool_Arr_u8_32_RTRN_bool_ctor (obj : * mut crate :: fermented :: generics :: Fn_ARGS_std_os_raw_c_void_Vec_u8_32_Arr_u8_32_bool_Arr_u8_32_RTRN_bool) -> * mut std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_Vec_u8_32_Arr_u8_32_bool_Arr_u8_32_RTRN_bool { ferment :: boxed (std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_Vec_u8_32_Arr_u8_32_bool_Arr_u8_32_RTRN_bool { obj }) } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_Vec_u8_32_Arr_u8_32_bool_Arr_u8_32_RTRN_bool_destroy (ffi : * mut std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_Vec_u8_32_Arr_u8_32_bool_Arr_u8_32_RTRN_bool) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_sync_Arc_example_entry_point_wallet_provider_WalletProvider { pub obj : * mut example_entry_point :: wallet_provider :: WalletProvider } impl ferment :: FFIConversionFrom < std :: sync :: Arc < example_entry_point :: wallet_provider :: WalletProvider > > for std_sync_Arc_example_entry_point_wallet_provider_WalletProvider { unsafe fn ffi_from_const (ffi : * const std_sync_Arc_example_entry_point_wallet_provider_WalletProvider) -> std :: sync :: Arc < example_entry_point :: wallet_provider :: WalletProvider > { let ffi_ref = & * ffi ; std :: sync :: Arc :: from_raw (ffi_ref . obj) } } impl ferment :: FFIConversionTo < std :: sync :: Arc < example_entry_point :: wallet_provider :: WalletProvider > > for std_sync_Arc_example_entry_point_wallet_provider_WalletProvider { unsafe fn ffi_to_const (obj : std :: sync :: Arc < example_entry_point :: wallet_provider :: WalletProvider >) -> * const std_sync_Arc_example_entry_point_wallet_provider_WalletProvider { ferment :: boxed (Self { obj : std :: sync :: Arc :: into_raw (obj) . cast_mut () }) } } impl Drop for std_sync_Arc_example_entry_point_wallet_provider_WalletProvider { fn drop (& mut self) { unsafe { ferment :: unbox_any (self . obj) ; } } } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_example_entry_point_wallet_provider_WalletProvider_ctor (obj : * mut example_entry_point :: wallet_provider :: WalletProvider) -> * mut std_sync_Arc_example_entry_point_wallet_provider_WalletProvider { ferment :: boxed (std_sync_Arc_example_entry_point_wallet_provider_WalletProvider { obj }) } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_example_entry_point_wallet_provider_WalletProvider_destroy (ffi : * mut std_sync_Arc_example_entry_point_wallet_provider_WalletProvider) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Fn_ARGS_u32_RTRN_Option_String { caller : unsafe extern "C" fn (u32) -> * mut std :: os :: raw :: c_char , destructor : unsafe extern "C" fn (* mut std :: os :: raw :: c_char) } impl Fn_ARGS_u32_RTRN_Option_String { pub unsafe fn call (& self , o_0 : u32) -> Option < String > { let ffi_result = (self . caller) (o_0) ; if ffi_result . is_null () { None } else { let result = < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from_opt (ffi_result) ; (self . destructor) (ffi_result) ; result } } } unsafe impl Send for Fn_ARGS_u32_RTRN_Option_String { } unsafe impl Sync for Fn_ARGS_u32_RTRN_Option_String { } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_u32_RTRN_Option_String_ctor (caller : unsafe extern "C" fn (u32) -> * mut std :: os :: raw :: c_char , destructor : unsafe extern "C" fn (* mut std :: os :: raw :: c_char)) -> * mut Fn_ARGS_u32_RTRN_Option_String { ferment :: boxed (Fn_ARGS_u32_RTRN_Option_String { caller , destructor }) } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_u32_RTRN_Option_String_destroy (ffi : * mut Fn_ARGS_u32_RTRN_Option_String) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_collections_Map_keys_u8_arr_32_values_i32 { pub count : usize , pub keys : * mut * mut crate :: fermented :: generics :: Arr_u8_32 , pub values : * mut i32 } impl ferment :: FFIConversionFrom < std :: collections :: HashMap < [u8 ; 32] , i32 > > for std_collections_Map_keys_u8_arr_32_values_i32 { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_u8_arr_32_values_i32) -> std :: collections :: HashMap < [u8 ; 32] , i32 > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | < crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionFrom < [u8 ; 32] >> :: ffi_from (o) , | o | o) } } impl ferment :: FFIConversionTo < std :: collections :: HashMap < [u8 ; 32] , i32 > > for std_collections_Map_keys_u8_arr_32_values_i32 { unsafe fn ffi_to_const (obj : std :: collections :: HashMap < [u8 ; 32] , i32 >) -> * const std_collections_Map_keys_u8_arr_32_values_i32 { ferment :: boxed (Self { count : obj . len () , keys : ferment :: to_complex_group (obj . keys () . cloned ()) , values : ferment :: to_primitive_group (obj . values () . cloned ()) }) } } impl Drop for std_collections_Map_keys_u8_arr_32_values_i32 { fn drop (& mut self) { unsafe { ferment :: unbox_any_vec_ptr (self . keys , self . count) ; ferment :: unbox_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_u8_arr_32_values_i32_ctor (count : usize , keys : * mut * mut crate :: fermented :: generics :: Arr_u8_32 , values : * mut i32) -> * mut std_collections_Map_keys_u8_arr_32_values_i32 { ferment :: boxed (std_collections_Map_keys_u8_arr_32_values_i32 { count , keys , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_u8_arr_32_values_i32_destroy (ffi : * mut std_collections_Map_keys_u8_arr_32_values_i32) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_u64_RTRN_u32 { pub obj : * mut crate :: fermented :: generics :: Fn_ARGS_std_os_raw_c_void_u64_RTRN_u32 } impl ferment :: FFIConversionFrom < std :: sync :: Arc < dyn Fn (* const std :: os :: raw :: c_void , u64) -> u32 > > for std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_u64_RTRN_u32 { unsafe fn ffi_from_const (ffi : * const std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_u64_RTRN_u32) -> std :: sync :: Arc < dyn Fn (* const std :: os :: raw :: c_void , u64) -> u32 > { let ffi_ref = & * ffi ; std :: sync :: Arc :: new (move | o_0 , o_1 | unsafe { (& * ffi_ref . obj) . call (o_0 , o_1) }) } } impl Drop for std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_u64_RTRN_u32 { fn drop (& mut self) { unsafe { ; } } } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_u64_RTRN_u32_ctor (obj : * mut crate :: fermented :: generics :: Fn_ARGS_std_os_raw_c_void_u64_RTRN_u32) -> * mut std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_u64_RTRN_u32 { ferment :: boxed (std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_u64_RTRN_u32 { obj }) } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_u64_RTRN_u32_destroy (ffi : * mut std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_u64_RTRN_u32) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Fn_ARGS_std_os_raw_c_void_std_net_SocketAddr_RTRN_bool { caller : unsafe extern "C" fn (* const std :: os :: raw :: c_void , * mut example_entry_point :: custom :: std :: SocketAddr) -> bool , destructor : unsafe extern "C" fn (bool) } impl Fn_ARGS_std_os_raw_c_void_std_net_SocketAddr_RTRN_bool { pub unsafe fn call (& self , o_0 : * const std :: os :: raw :: c_void , o_1 : std :: net :: SocketAddr) -> bool { let ffi_result = (self . caller) (o_0 , < example_entry_point :: custom :: std :: SocketAddr as ferment :: FFIConversionTo < std :: net :: SocketAddr >> :: ffi_to (o_1)) ; ffi_result } } unsafe impl Send for Fn_ARGS_std_os_raw_c_void_std_net_SocketAddr_RTRN_bool { } unsafe impl Sync for Fn_ARGS_std_os_raw_c_void_std_net_SocketAddr_RTRN_bool { } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_std_os_raw_c_void_std_net_SocketAddr_RTRN_bool_ctor (caller : unsafe extern "C" fn (* const std :: os :: raw :: c_void , * mut example_entry_point :: custom :: std :: SocketAddr) -> bool , destructor : unsafe extern "C" fn (bool)) -> * mut Fn_ARGS_std_os_raw_c_void_std_net_SocketAddr_RTRN_bool { ferment :: boxed (Fn_ARGS_std_os_raw_c_void_std_net_SocketAddr_RTRN_bool { caller , destructor }) } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_std_os_raw_c_void_std_net_SocketAddr_RTRN_bool_destroy (ffi : * mut Fn_ARGS_std_os_raw_c_void_std_net_SocketAddr_RTRN_bool) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Fn_ARGS_example_entry_point_entry_FFIContext_u32_Arr_u8_32_u32_RTRN_Result_ok_u8_arr_48_err_String { caller : unsafe extern "C" fn (* const example_entry_point :: entry :: FFIContext , u32 , * mut crate :: fermented :: generics :: Arr_u8_32 , u32) -> * mut crate :: fermented :: generics :: Result_ok_u8_arr_48_err_String , destructor : unsafe extern "C" fn (* mut crate :: fermented :: generics :: Result_ok_u8_arr_48_err_String) } impl Fn_ARGS_example_entry_point_entry_FFIContext_u32_Arr_u8_32_u32_RTRN_Result_ok_u8_arr_48_err_String { pub unsafe fn call (& self , o_0 : * const example_entry_point :: entry :: FFIContext , o_1 : u32 , o_2 : [u8 ; 32] , o_3 : u32) -> Result < [u8 ; 48] , String > { let ffi_result = (self . caller) (o_0 , o_1 , < crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionTo < [u8 ; 32] >> :: ffi_to (o_2) , o_3) ; let result = < crate :: fermented :: generics :: Result_ok_u8_arr_48_err_String as ferment :: FFIConversionFrom < Result < [u8 ; 48] , String > >> :: ffi_from (ffi_result) ; (self . destructor) (ffi_result) ; result } } unsafe impl Send for Fn_ARGS_example_entry_point_entry_FFIContext_u32_Arr_u8_32_u32_RTRN_Result_ok_u8_arr_48_err_String { } unsafe impl Sync for Fn_ARGS_example_entry_point_entry_FFIContext_u32_Arr_u8_32_u32_RTRN_Result_ok_u8_arr_48_err_String { } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_example_entry_point_entry_FFIContext_u32_Arr_u8_32_u32_RTRN_Result_ok_u8_arr_48_err_String_ctor (caller : unsafe extern "C" fn (* const example_entry_point :: entry :: FFIContext , u32 , * mut crate :: fermented :: generics :: Arr_u8_32 , u32) -> * mut crate :: fermented :: generics :: Result_ok_u8_arr_48_err_String , destructor : unsafe extern "C" fn (* mut crate :: fermented :: generics :: Result_ok_u8_arr_48_err_String)) -> * mut Fn_ARGS_example_entry_point_entry_FFIContext_u32_Arr_u8_32_u32_RTRN_Result_ok_u8_arr_48_err_String { ferment :: boxed (Fn_ARGS_example_entry_point_entry_FFIContext_u32_Arr_u8_32_u32_RTRN_Result_ok_u8_arr_48_err_String { caller , destructor }) } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_example_entry_point_entry_FFIContext_u32_Arr_u8_32_u32_RTRN_Result_ok_u8_arr_48_err_String_destroy (ffi : * mut Fn_ARGS_example_entry_point_entry_FFIContext_u32_Arr_u8_32_u32_RTRN_Result_ok_u8_arr_48_err_String) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_collections_Map_keys_u8_arr_32_values_bool { pub count : usize , pub keys : * mut * mut crate :: fermented :: generics :: Arr_u8_32 , pub values : * mut bool } impl ferment :: FFIConversionFrom < std :: collections :: HashMap < [u8 ; 32] , bool > > for std_collections_Map_keys_u8_arr_32_values_bool { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_u8_arr_32_values_bool) -> std :: collections :: HashMap < [u8 ; 32] , bool > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | < crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionFrom < [u8 ; 32] >> :: ffi_from (o) , | o | o) } } impl ferment :: FFIConversionTo < std :: collections :: HashMap < [u8 ; 32] , bool > > for std_collections_Map_keys_u8_arr_32_values_bool { unsafe fn ffi_to_const (obj : std :: collections :: HashMap < [u8 ; 32] , bool >) -> * const std_collections_Map_keys_u8_arr_32_values_bool { ferment :: boxed (Self { count : obj . len () , keys : ferment :: to_complex_group (obj . keys () . cloned ()) , values : ferment :: to_primitive_group (obj . values () . cloned ()) }) } } impl Drop for std_collections_Map_keys_u8_arr_32_values_bool { fn drop (& mut self) { unsafe { ferment :: unbox_any_vec_ptr (self . keys , self . count) ; ferment :: unbox_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_u8_arr_32_values_bool_ctor (count : usize , keys : * mut * mut crate :: fermented :: generics :: Arr_u8_32 , values : * mut bool) -> * mut std_collections_Map_keys_u8_arr_32_values_bool { ferment :: boxed (std_collections_Map_keys_u8_arr_32_values_bool { count , keys , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_u8_arr_32_values_bool_destroy (ffi : * mut std_collections_Map_keys_u8_arr_32_values_bool) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Vec_u8_32 { pub count : usize , pub values : * mut * mut crate :: fermented :: generics :: Arr_u8_32 } impl ferment :: FFIConversionFrom < Vec < [u8 ; 32] > > for Vec_u8_32 { unsafe fn ffi_from_const (ffi : * const Vec_u8_32) -> Vec < [u8 ; 32] > { let ffi_ref = & * ffi ; ferment :: from_complex_group (ffi_ref . values , ffi_ref . count) } } impl ferment :: FFIConversionTo < Vec < [u8 ; 32] > > for Vec_u8_32 { unsafe fn ffi_to_const (obj : Vec < [u8 ; 32] >) -> * const Vec_u8_32 { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_complex_group (obj . into_iter ()) }) } } impl Drop for Vec_u8_32 { fn drop (& mut self) { unsafe { ferment :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn Vec_u8_32_ctor (count : usize , values : * mut * mut crate :: fermented :: generics :: Arr_u8_32) -> * mut Vec_u8_32 { ferment :: boxed (Vec_u8_32 { count , values }) } # [no_mangle] pub unsafe extern "C" fn Vec_u8_32_destroy (ffi : * mut Vec_u8_32) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_bool_RTRN_Vec_Vec_u8 { pub obj : * mut crate :: fermented :: generics :: Fn_ARGS_std_os_raw_c_void_bool_RTRN_Vec_Vec_u8 } impl ferment :: FFIConversionFrom < std :: sync :: Arc < dyn Fn (* const std :: os :: raw :: c_void , bool) -> Vec < Vec < u8 > > > > for std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_bool_RTRN_Vec_Vec_u8 { unsafe fn ffi_from_const (ffi : * const std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_bool_RTRN_Vec_Vec_u8) -> std :: sync :: Arc < dyn Fn (* const std :: os :: raw :: c_void , bool) -> Vec < Vec < u8 > > > { let ffi_ref = & * ffi ; std :: sync :: Arc :: new (move | o_0 , o_1 | unsafe { (& * ffi_ref . obj) . call (o_0 , o_1) }) } } impl Drop for std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_bool_RTRN_Vec_Vec_u8 { fn drop (& mut self) { unsafe { ; } } } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_bool_RTRN_Vec_Vec_u8_ctor (obj : * mut crate :: fermented :: generics :: Fn_ARGS_std_os_raw_c_void_bool_RTRN_Vec_Vec_u8) -> * mut std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_bool_RTRN_Vec_Vec_u8 { ferment :: boxed (std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_bool_RTRN_Vec_Vec_u8 { obj }) } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_bool_RTRN_Vec_Vec_u8_destroy (ffi : * mut std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_bool_RTRN_Vec_Vec_u8) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_RTRN_bool { pub obj : * mut crate :: fermented :: generics :: Fn_ARGS_std_os_raw_c_void_RTRN_bool } impl ferment :: FFIConversionFrom < std :: sync :: Arc < dyn Fn (* const std :: os :: raw :: c_void) -> bool > > for std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_RTRN_bool { unsafe fn ffi_from_const (ffi : * const std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_RTRN_bool) -> std :: sync :: Arc < dyn Fn (* const std :: os :: raw :: c_void) -> bool > { let ffi_ref = & * ffi ; std :: sync :: Arc :: new (move | o_0 | unsafe { (& * ffi_ref . obj) . call (o_0) }) } } impl Drop for std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_RTRN_bool { fn drop (& mut self) { unsafe { ; } } } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_RTRN_bool_ctor (obj : * mut crate :: fermented :: generics :: Fn_ARGS_std_os_raw_c_void_RTRN_bool) -> * mut std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_RTRN_bool { ferment :: boxed (std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_RTRN_bool { obj }) } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_RTRN_bool_destroy (ffi : * mut std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_RTRN_bool) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Fn_ARGS_std_os_raw_c_void_String_RTRN_bool { caller : unsafe extern "C" fn (* const std :: os :: raw :: c_void , * mut std :: os :: raw :: c_char) -> bool , destructor : unsafe extern "C" fn (bool) } impl Fn_ARGS_std_os_raw_c_void_String_RTRN_bool { pub unsafe fn call (& self , o_0 : * const std :: os :: raw :: c_void , o_1 : String) -> bool { let ffi_result = (self . caller) (o_0 , < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_1)) ; ffi_result } } unsafe impl Send for Fn_ARGS_std_os_raw_c_void_String_RTRN_bool { } unsafe impl Sync for Fn_ARGS_std_os_raw_c_void_String_RTRN_bool { } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_std_os_raw_c_void_String_RTRN_bool_ctor (caller : unsafe extern "C" fn (* const std :: os :: raw :: c_void , * mut std :: os :: raw :: c_char) -> bool , destructor : unsafe extern "C" fn (bool)) -> * mut Fn_ARGS_std_os_raw_c_void_String_RTRN_bool { ferment :: boxed (Fn_ARGS_std_os_raw_c_void_String_RTRN_bool { caller , destructor }) } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_std_os_raw_c_void_String_RTRN_bool_destroy (ffi : * mut Fn_ARGS_std_os_raw_c_void_String_RTRN_bool) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Fn_ARGS_std_os_raw_c_void_RTRN_ { caller : unsafe extern "C" fn (* const std :: os :: raw :: c_void) } impl Fn_ARGS_std_os_raw_c_void_RTRN_ { pub unsafe fn call (& self , o_0 : * const std :: os :: raw :: c_void) { let ffi_result = (self . caller) (o_0) ; ffi_result } } unsafe impl Send for Fn_ARGS_std_os_raw_c_void_RTRN_ { } unsafe impl Sync for Fn_ARGS_std_os_raw_c_void_RTRN_ { } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_std_os_raw_c_void_RTRN__ctor (caller : unsafe extern "C" fn (* const std :: os :: raw :: c_void)) -> * mut Fn_ARGS_std_os_raw_c_void_RTRN_ { ferment :: boxed (Fn_ARGS_std_os_raw_c_void_RTRN_ { caller }) } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_std_os_raw_c_void_RTRN__destroy (ffi : * mut Fn_ARGS_std_os_raw_c_void_RTRN_) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_bool_bool_bool_i32_RTRN_Vec_u8_32 { pub obj : * mut crate :: fermented :: generics :: Fn_ARGS_std_os_raw_c_void_bool_bool_bool_i32_RTRN_Vec_u8_32 } impl ferment :: FFIConversionFrom < std :: sync :: Arc < dyn Fn (* const std :: os :: raw :: c_void , bool , bool , bool , i32) -> Vec < [u8 ; 32] > > > for std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_bool_bool_bool_i32_RTRN_Vec_u8_32 { unsafe fn ffi_from_const (ffi : * const std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_bool_bool_bool_i32_RTRN_Vec_u8_32) -> std :: sync :: Arc < dyn Fn (* const std :: os :: raw :: c_void , bool , bool , bool , i32) -> Vec < [u8 ; 32] > > { let ffi_ref = & * ffi ; std :: sync :: Arc :: new (move | o_0 , o_1 , o_2 , o_3 , o_4 | unsafe { (& * ffi_ref . obj) . call (o_0 , o_1 , o_2 , o_3 , o_4) }) } } impl Drop for std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_bool_bool_bool_i32_RTRN_Vec_u8_32 { fn drop (& mut self) { unsafe { ; } } } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_bool_bool_bool_i32_RTRN_Vec_u8_32_ctor (obj : * mut crate :: fermented :: generics :: Fn_ARGS_std_os_raw_c_void_bool_bool_bool_i32_RTRN_Vec_u8_32) -> * mut std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_bool_bool_bool_i32_RTRN_Vec_u8_32 { ferment :: boxed (std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_bool_bool_bool_i32_RTRN_Vec_u8_32 { obj }) } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_bool_bool_bool_i32_RTRN_Vec_u8_32_destroy (ffi : * mut std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_bool_bool_bool_i32_RTRN_Vec_u8_32) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_String_Vec_u8_Option_std_net_SocketAddr_bool_RTRN_bool { pub obj : * mut crate :: fermented :: generics :: Fn_ARGS_std_os_raw_c_void_String_Vec_u8_Option_std_net_SocketAddr_bool_RTRN_bool } impl ferment :: FFIConversionFrom < std :: sync :: Arc < dyn Fn (* const std :: os :: raw :: c_void , String , Vec < u8 > , Option < std :: net :: SocketAddr > , bool) -> bool > > for std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_String_Vec_u8_Option_std_net_SocketAddr_bool_RTRN_bool { unsafe fn ffi_from_const (ffi : * const std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_String_Vec_u8_Option_std_net_SocketAddr_bool_RTRN_bool) -> std :: sync :: Arc < dyn Fn (* const std :: os :: raw :: c_void , String , Vec < u8 > , Option < std :: net :: SocketAddr > , bool) -> bool > { let ffi_ref = & * ffi ; std :: sync :: Arc :: new (move | o_0 , o_1 , o_2 , o_3 , o_4 | unsafe { (& * ffi_ref . obj) . call (o_0 , o_1 , o_2 , o_3 , o_4) }) } } impl Drop for std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_String_Vec_u8_Option_std_net_SocketAddr_bool_RTRN_bool { fn drop (& mut self) { unsafe { ; } } } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_String_Vec_u8_Option_std_net_SocketAddr_bool_RTRN_bool_ctor (obj : * mut crate :: fermented :: generics :: Fn_ARGS_std_os_raw_c_void_String_Vec_u8_Option_std_net_SocketAddr_bool_RTRN_bool) -> * mut std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_String_Vec_u8_Option_std_net_SocketAddr_bool_RTRN_bool { ferment :: boxed (std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_String_Vec_u8_Option_std_net_SocketAddr_bool_RTRN_bool { obj }) } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_String_Vec_u8_Option_std_net_SocketAddr_bool_RTRN_bool_destroy (ffi : * mut std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_String_Vec_u8_Option_std_net_SocketAddr_bool_RTRN_bool) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_bool_Arr_u8_32_example_entry_point_wallet_WalletEx_RTRN_Vec_u8_32 { pub obj : * mut crate :: fermented :: generics :: Fn_ARGS_std_os_raw_c_void_bool_Arr_u8_32_example_entry_point_wallet_WalletEx_RTRN_Vec_u8_32 } impl ferment :: FFIConversionFrom < std :: sync :: Arc < dyn Fn (* const std :: os :: raw :: c_void , bool , [u8 ; 32] , example_entry_point :: wallet :: WalletEx) -> Vec < [u8 ; 32] > > > for std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_bool_Arr_u8_32_example_entry_point_wallet_WalletEx_RTRN_Vec_u8_32 { unsafe fn ffi_from_const (ffi : * const std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_bool_Arr_u8_32_example_entry_point_wallet_WalletEx_RTRN_Vec_u8_32) -> std :: sync :: Arc < dyn Fn (* const std :: os :: raw :: c_void , bool , [u8 ; 32] , example_entry_point :: wallet :: WalletEx) -> Vec < [u8 ; 32] > > { let ffi_ref = & * ffi ; std :: sync :: Arc :: new (move | o_0 , o_1 , o_2 , o_3 | unsafe { (& * ffi_ref . obj) . call (o_0 , o_1 , o_2 , o_3) }) } } impl Drop for std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_bool_Arr_u8_32_example_entry_point_wallet_WalletEx_RTRN_Vec_u8_32 { fn drop (& mut self) { unsafe { ; } } } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_bool_Arr_u8_32_example_entry_point_wallet_WalletEx_RTRN_Vec_u8_32_ctor (obj : * mut crate :: fermented :: generics :: Fn_ARGS_std_os_raw_c_void_bool_Arr_u8_32_example_entry_point_wallet_WalletEx_RTRN_Vec_u8_32) -> * mut std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_bool_Arr_u8_32_example_entry_point_wallet_WalletEx_RTRN_Vec_u8_32 { ferment :: boxed (std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_bool_Arr_u8_32_example_entry_point_wallet_WalletEx_RTRN_Vec_u8_32 { obj }) } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_bool_Arr_u8_32_example_entry_point_wallet_WalletEx_RTRN_Vec_u8_32_destroy (ffi : * mut std_sync_Arc_dyn_trait_Fn_ARGS_std_os_raw_c_void_bool_Arr_u8_32_example_entry_point_wallet_WalletEx_RTRN_Vec_u8_32) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Fn_ARGS_std_os_raw_c_void_Arr_u8_32_bool_RTRN_Option_u8_32 { caller : unsafe extern "C" fn (* const std :: os :: raw :: c_void , * mut crate :: fermented :: generics :: Arr_u8_32 , bool) -> * mut crate :: fermented :: generics :: Arr_u8_32 , destructor : unsafe extern "C" fn (* mut crate :: fermented :: generics :: Arr_u8_32) } impl Fn_ARGS_std_os_raw_c_void_Arr_u8_32_bool_RTRN_Option_u8_32 { pub unsafe fn call (& self , o_0 : * const std :: os :: raw :: c_void , o_1 : [u8 ; 32] , o_2 : bool) -> Option < [u8 ; 32] > { let ffi_result = (self . caller) (o_0 , < crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionTo < [u8 ; 32] >> :: ffi_to (o_1) , o_2) ; let result = < crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionFrom < [u8 ; 32] >> :: ffi_from_opt (ffi_result) ; (self . destructor) (ffi_result) ; result } } unsafe impl Send for Fn_ARGS_std_os_raw_c_void_Arr_u8_32_bool_RTRN_Option_u8_32 { } unsafe impl Sync for Fn_ARGS_std_os_raw_c_void_Arr_u8_32_bool_RTRN_Option_u8_32 { } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_std_os_raw_c_void_Arr_u8_32_bool_RTRN_Option_u8_32_ctor (caller : unsafe extern "C" fn (* const std :: os :: raw :: c_void , * mut crate :: fermented :: generics :: Arr_u8_32 , bool) -> * mut crate :: fermented :: generics :: Arr_u8_32 , destructor : unsafe extern "C" fn (* mut crate :: fermented :: generics :: Arr_u8_32)) -> * mut Fn_ARGS_std_os_raw_c_void_Arr_u8_32_bool_RTRN_Option_u8_32 { ferment :: boxed (Fn_ARGS_std_os_raw_c_void_Arr_u8_32_bool_RTRN_Option_u8_32 { caller , destructor }) } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_std_os_raw_c_void_Arr_u8_32_bool_RTRN_Option_u8_32_destroy (ffi : * mut Fn_ARGS_std_os_raw_c_void_Arr_u8_32_bool_RTRN_Option_u8_32) { ferment :: unbox_any (ffi) ; } }